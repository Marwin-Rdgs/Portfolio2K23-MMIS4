import { has, regexForFormat, eq, empty } from '@formkit/utils';

/**
 * Determine if the given input's value was should be considered "accepted".
 * @param context - The FormKitValidationContext
 * @public
 */
const accepted = function accepted({ value }) {
    return ['yes', 'on', '1', 1, true, 'true'].includes(value);
};
accepted.skipEmpty = false;

/**
 * Determine if the given input's value is after a given date.
 * Defaults to current time.
 * @param context - The FormKitValidationContext
 * @public
 */
const date_after = function ({ value }, compare = false) {
    const timestamp = Date.parse(compare || new Date());
    const fieldValue = Date.parse(String(value));
    return isNaN(fieldValue) ? false : fieldValue > timestamp;
};

/**
 * Determine if the given input's value is only alpha characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const alpha = function ({ value }, set = 'default') {
    const sets = {
        default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćČčĎďĘęĚěŁłŃńŇňŘřŚśŠšŤťŮůŹźŻŽžż]+$/,
        latin: /^[a-zA-Z]+$/,
    };
    const selectedSet = has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value is only alpha characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const alpha_spaces = function ({ value }, set = 'default') {
    const sets = {
        default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćČčĎďĘęĚěŁłŃńŇňŘřŚśŠšŤťŮůŹźŻŽžż ]+$/,
        latin: /^[a-zA-Z ]+$/,
    };
    const selectedSet = has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value is only alpha or numeric characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const alphanumeric = function ({ value }, set = 'default') {
    const sets = {
        default: /^[a-zA-Z0-9À-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,
        latin: /^[a-zA-Z0-9]+$/,
    };
    const selectedSet = has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value before a given date.
 * @param context - The FormKitValidationContext
 * @public
 */
const date_before = function ({ value }, compare = false) {
    const timestamp = Date.parse(compare || new Date());
    const fieldValue = Date.parse(String(value));
    return isNaN(fieldValue) ? false : fieldValue < timestamp;
};

/**
 * Determine if the given input's value is between two other values.
 * @param context - The FormKitValidationContext
 * @public
 */
const between = function between({ value }, from, to) {
    if (!isNaN(value) && !isNaN(from) && !isNaN(to)) {
        const val = 1 * value;
        from = Number(from);
        to = Number(to);
        const [a, b] = from <= to ? [from, to] : [to, from];
        return val >= 1 * a && val <= 1 * b;
    }
    return false;
};

const hasConfirm = /(_confirm(?:ed)?)$/;
/**
 * Determine if the given input's value matches another input's value
 * @param context - The FormKitValidationContext
 * @public
 */
const confirm = function confirm(node, address, comparison = 'loose') {
    var _a;
    if (!address) {
        address = hasConfirm.test(node.name)
            ? node.name.replace(hasConfirm, '')
            : `${node.name}_confirm`;
    }
    const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;
    return comparison === 'strict'
        ? node.value === foreignValue
        : node.value == foreignValue;
};

/**
 * Determine if the given input's value is between two other dates
 * @param context - The FormKitValidationContext
 * @public
 */
const date_between = function date_between({ value }, dateA, dateB) {
    dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);
    dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);
    const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));
    if (dateA && !dateB) {
        dateB = dateA;
        dateA = Date.now();
    }
    else if (!dateA || !compareTo) {
        return false;
    }
    return compareTo >= dateA && compareTo <= dateB;
};

/**
 * Determine if the given input's value matches a specified date format
 * @param context - The FormKitValidationContext
 * @public
 */
const date_format = function date({ value }, format) {
    if (format && typeof format === 'string') {
        return regexForFormat(format).test(String(value));
    }
    return !isNaN(Date.parse(String(value)));
};

/**
 * Determine if the given input's value is a plausible email address.
 * @param context - The FormKitValidationContext
 * @public
 */
const email = function email({ value }) {
    const isEmail = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
    return isEmail.test(String(value));
};

/**
 * Determine if the given input's value ends with a given string
 * @param context - The FormKitValidationContext
 * @public
 */
const ends_with = function ends_with({ value }, ...stack) {
    if (typeof value === 'string' && stack.length) {
        return stack.some((item) => {
            return value.endsWith(item);
        });
    }
    else if (typeof value === 'string' && stack.length === 0) {
        return true;
    }
    return false;
};

/**
 * Determine if the given input's value is in a set of possible values.
 * @param context - The FormKitValidationContext
 * @public
 */
const is = function is({ value }, ...stack) {
    return stack.some((item) => {
        if (typeof item === 'object') {
            return eq(item, value);
        }
        return item == value;
    });
};

/**
 * Determine if the given input's value length is full width.
 * @param context - The FormKitValidationContext
 * @public
 */
const length = function length({ value }, first = 0, second = Infinity) {
    first = parseInt(first);
    second = isNaN(parseInt(second)) ? Infinity : parseInt(second);
    const min = first <= second ? first : second;
    const max = second >= first ? second : first;
    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length >= min && value.length <= max;
    }
    else if (value && typeof value === 'object') {
        const length = Object.keys(value).length;
        return length >= min && length <= max;
    }
    return false;
};

/**
 * Determine if the given input's value matches one or more values or regular expressions.
 * @param context - The FormKitValidationContext
 * @public
 */
const matches = function matches({ value }, ...stack) {
    return stack.some((pattern) => {
        if (typeof pattern === 'string' &&
            pattern.substr(0, 1) === '/' &&
            pattern.substr(-1) === '/') {
            pattern = new RegExp(pattern.substr(1, pattern.length - 2));
        }
        if (pattern instanceof RegExp) {
            return pattern.test(String(value));
        }
        return pattern === value;
    });
};

/**
 * Determine if the given input's value is less than the maximum
 * @param context - The FormKitValidationContext
 * @public
 */
const max = function max({ value }, maximum = 10) {
    if (Array.isArray(value)) {
        return value.length <= maximum;
    }
    return Number(value) <= Number(maximum);
};

/**
 * Determine if the given input's value is less than a certain value.
 * @param context - The FormKitValidationContext
 * @public
 */
const min = function min({ value }, minimum = 1) {
    if (Array.isArray(value)) {
        return value.length >= minimum;
    }
    return Number(value) >= Number(minimum);
};

/**
 * Determine if the given input's value is not in a given stack
 * @param context - The FormKitValidationContext
 * @public
 */
const not = function not({ value }, ...stack) {
    return !stack.some((item) => {
        if (typeof item === 'object') {
            return eq(item, value);
        }
        return item === value;
    });
};

/**
 * Determine if the given input's value is numeric
 * @param context - The FormKitValidationContext
 * @public
 */
const number = function number({ value }) {
    return !isNaN(value);
};

/**
 * Determine if the given input's value was required.
 * @param context - The FormKitValidationContext
 * @public
 */
const required = function required({ value }, action = 'default') {
    return action === 'trim' && typeof value === 'string'
        ? !empty(value.trim())
        : !empty(value);
};
/**
 * This rules should run even if the inputs is empty (obviously)
 */
required.skipEmpty = false;

/**
 * Determine if the given input's value starts with a substring
 * @param context - The FormKitValidationContext
 * @public
 */
const starts_with = function starts_with({ value }, ...stack) {
    if (typeof value === 'string' && stack.length) {
        return stack.some((item) => {
            return value.startsWith(item);
        });
    }
    else if (typeof value === 'string' && stack.length === 0) {
        return true;
    }
    return false;
};

/**
 * Determine if the given input's value is an http url
 * @param context - The FormKitValidationContext
 * @public
 */
const url = function url({ value }, ...stack) {
    try {
        const protocols = stack.length ? stack : ['http:', 'https:'];
        const url = new URL(String(value));
        return protocols.includes(url.protocol);
    }
    catch {
        return false;
    }
};

export { accepted, alpha, alpha_spaces, alphanumeric, between, confirm, date_after, date_before, date_between, date_format, email, ends_with, is, length, matches, max, min, not, number, required, starts_with, url };
