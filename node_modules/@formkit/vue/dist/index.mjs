import { warn, getNode, watchRegistry, isNode, sugar, isDOM, isComponent as isComponent$1, isConditional, compile, error, createConfig, clearErrors, setErrors, submitForm, reset, createNode, createMessage, createClasses, generateClassList } from '@formkit/core';
export { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';
import { defineComponent, getCurrentInstance, watch, watchEffect, reactive, ref, createTextVNode, resolveComponent, h, isRef, isReactive, toRaw, inject, computed, provide, toRef, onBeforeUnmount, markRaw, nextTick, triggerRef } from 'vue';
import { has, isPojo, cloneAny, extend, camel, kebab, nodeProps, only, except, slugify, isObject, token, empty, eq, shallowClone, undefine } from '@formkit/utils';
import { createSection, useSchema, createLibraryPlugin, inputs } from '@formkit/inputs';
import * as defaultRules from '@formkit/rules';
import { createValidationPlugin } from '@formkit/validation';
import { createI18nPlugin, en } from '@formkit/i18n';
import { createThemePlugin, createIconHandler } from '@formkit/themes';
import { createObserver } from '@formkit/observer';
import '@formkit/dev';

/**
 * A registry of memoized schemas (in JSON) to their respective render function
 * and provider registry.
 */
const memo = {};
/**
 * This symbol represents the current component instance during render. It is
 * critical for linking the current instance to the data required for render.
 */
let instanceKey;
/**
 * A registry of scoped data produced during runtime that is keyed by the
 * instance symbol. For example data from: for-loop instances and slot data.
 */
const instanceScopes = new Map();
/**
 * Indicates the a section of the schema is raw.
 */
const raw = '__raw__';
/**
 * Is a class prop.
 */
const isClassProp = /[a-zA-Z0-9\-][cC]lass$/;
/**
 * Returns a reference as a placeholder to a specific location on an object.
 * @param data - A reactive data object
 * @param token - A dot-syntax string representing the object path
 * @returns
 */
function getRef(token, data) {
    const value = ref(null);
    if (token === 'get') {
        const nodeRefs = {};
        value.value = get$1.bind(null, nodeRefs);
        return value;
    }
    const path = token.split('.');
    watchEffect(() => (value.value = getValue(data, path)));
    return value;
}
/**
 * Returns a value inside a set of data objects.
 * @param sets - An array of objects to search through
 * @param path - A array of string paths easily produced by split()
 * @returns
 */
function getValue(set, path) {
    if (Array.isArray(set)) {
        for (const subset of set) {
            const value = subset !== false && getValue(subset, path);
            if (value !== undefined)
                return value;
        }
        return undefined;
    }
    let foundValue = undefined;
    let obj = set;
    for (const i in path) {
        const key = path[i];
        if (typeof obj !== 'object' || obj === null) {
            foundValue = undefined;
            break;
        }
        const currentValue = obj[key];
        if (Number(i) === path.length - 1 && currentValue !== undefined) {
            // When the value is a function, we need to bind the `this` value
            // before providing this back to the compiler.
            foundValue =
                typeof currentValue === 'function'
                    ? currentValue.bind(obj)
                    : currentValue;
            break;
        }
        obj = currentValue;
    }
    return foundValue;
}
/**
 * Get the node from the global registry
 * @param id - A dot-syntax string where the node is located.
 */
function get$1(nodeRefs, id) {
    if (typeof id !== 'string')
        return warn(650);
    if (!(id in nodeRefs))
        nodeRefs[id] = ref(undefined);
    if (nodeRefs[id].value === undefined) {
        nodeRefs[id].value = null;
        const root = getNode(id);
        if (root)
            nodeRefs[id].value = root.context;
        watchRegistry(id, ({ payload: node }) => {
            nodeRefs[id].value = isNode(node) ? node.context : node;
        });
    }
    return nodeRefs[id].value;
}
/**
 *
 * @param library - A library of concrete components to use
 * @param schema -
 * @returns
 */
function parseSchema(library, schema) {
    /**
     * Given an if/then/else schema node, pre-compile the node and return the
     * artifacts for the render function.
     * @param data - The schema context object
     * @param library - The available components
     * @param node - The node to parse
     */
    function parseCondition(library, node) {
        const condition = provider(compile(node.if), { if: true });
        const children = createElements(library, node.then);
        const alternate = node.else ? createElements(library, node.else) : null;
        return [condition, children, alternate];
    }
    /**
     * Parses a conditional if/then/else attribute statement.
     * @param data - The data object
     * @param attr - The attribute
     * @param _default - The default value
     * @returns
     */
    function parseConditionAttr(attr, _default) {
        var _a, _b;
        const condition = provider(compile(attr.if));
        let b = () => _default;
        let a = () => _default;
        if (typeof attr.then === 'object') {
            a = parseAttrs(attr.then, undefined);
        }
        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {
            a = provider(compile(attr.then));
        }
        else {
            a = () => attr.then;
        }
        if (has(attr, 'else')) {
            if (typeof attr.else === 'object') {
                b = parseAttrs(attr.else);
            }
            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {
                b = provider(compile(attr.else));
            }
            else {
                b = () => attr.else;
            }
        }
        return () => (condition() ? a() : b());
    }
    /**
     * Parse attributes for dynamic content.
     * @param attrs - Object of attributes
     * @returns
     */
    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {
        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));
        const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});
        const staticAttrs = {};
        const setters = [
            (attrs) => {
                const bound = boundAttrs();
                for (const attr in bound) {
                    if (!explicitAttrs.has(attr)) {
                        attrs[attr] = bound[attr];
                    }
                }
            },
        ];
        if (unparsedAttrs) {
            if (isConditional(unparsedAttrs)) {
                // This is a root conditional object that must produce an object of
                // attributes.
                const condition = parseConditionAttr(unparsedAttrs, _default);
                return condition;
            }
            // Some attributes are explicitly bound, we need to parse those ones
            // using the compiler and create a dynamic "setter".
            for (let attr in unparsedAttrs) {
                const value = unparsedAttrs[attr];
                let getValue;
                const isStr = typeof value === 'string';
                if (attr.startsWith(raw)) {
                    // attributes prefixed with __raw__ should not be parsed
                    attr = attr.substring(7);
                    getValue = () => value;
                }
                else if (isStr &&
                    value.startsWith('$') &&
                    value.length > 1 &&
                    !(value.startsWith('$reset') && isClassProp.test(attr))) {
                    // Most attribute values starting with $ should be compiled
                    // -class attributes starting with `$reset` should not be compiled
                    getValue = provider(compile(value));
                }
                else if (typeof value === 'object' && isConditional(value)) {
                    // Conditional attrs require further processing
                    getValue = parseConditionAttr(value, undefined);
                }
                else if (typeof value === 'object' && isPojo(value)) {
                    // Sub-parse pojos
                    getValue = parseAttrs(value);
                }
                else {
                    // In all other cases, the value is static
                    getValue = () => value;
                    staticAttrs[attr] = value;
                }
                setters.push((attrs) => {
                    attrs[attr] = getValue();
                });
            }
        }
        return () => {
            const attrs = Array.isArray(unparsedAttrs) ? [] : {};
            setters.forEach((setter) => setter(attrs));
            return attrs;
        };
    }
    /**
     * Given a single schema node, parse it and extract the value.
     * @param data - A state object provided to each node
     * @param node - The schema node being parsed
     * @returns
     */
    function parseNode(library, _node) {
        let element = null;
        let attrs = () => null;
        let condition = false;
        let children = null;
        let alternate = null;
        let iterator = null;
        let resolve = false;
        const node = sugar(_node);
        if (isDOM(node)) {
            // This is an actual HTML DOM element
            element = node.$el;
            attrs =
                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;
        }
        else if (isComponent$1(node)) {
            // This is a Vue Component
            if (typeof node.$cmp === 'string') {
                if (has(library, node.$cmp)) {
                    element = library[node.$cmp];
                }
                else {
                    element = node.$cmp;
                    resolve = true;
                }
            }
            else {
                // in this case it must be an actual component
                element = node.$cmp;
            }
            attrs = parseAttrs(node.props, node.bind);
        }
        else if (isConditional(node)) {
            [condition, children, alternate] = parseCondition(library, node);
        }
        // This is the same as a "v-if" statement — not an if/else statement
        if (!isConditional(node) && 'if' in node) {
            condition = provider(compile(node.if));
        }
        else if (!isConditional(node) && element === null) {
            // In this odd case our element is actually a partial and
            // we only want to render the children.
            condition = () => true;
        }
        // Compile children down to a function
        if ('children' in node && node.children) {
            if (typeof node.children === 'string') {
                // We are dealing with a raw string value
                if (node.children.startsWith('$slots.')) {
                    // this is a lone text node, turn it into a slot
                    element = element === 'text' ? 'slot' : element;
                    children = provider(compile(node.children));
                }
                else if (node.children.startsWith('$') && node.children.length > 1) {
                    const value = provider(compile(node.children));
                    children = () => String(value());
                }
                else {
                    children = () => String(node.children);
                }
            }
            else if (Array.isArray(node.children)) {
                // We are dealing with node sub-children
                children = createElements(library, node.children);
            }
            else {
                // This is a conditional if/else clause
                const [childCondition, c, a] = parseCondition(library, node.children);
                children = (iterationData) => childCondition && childCondition()
                    ? c && c(iterationData)
                    : a && a(iterationData);
            }
        }
        if (isComponent$1(node)) {
            if (children) {
                // Children of components need to be provided as an object of slots
                // so we provide an object with the default slot provided as children.
                // We also create a new scope for this default slot, and then on each
                // render pass the scoped slot props to the scope.
                const produceChildren = children;
                children = (iterationData) => {
                    return {
                        default(slotData, key) {
                            var _a, _b, _c, _d;
                            // We need to switch the current instance key back to the one that
                            // originally called this component's render function.
                            const currentKey = instanceKey;
                            if (key)
                                instanceKey = key;
                            if (slotData)
                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);
                            if (iterationData)
                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);
                            const c = produceChildren(iterationData);
                            // Ensure our instance key never changed during runtime
                            if (slotData)
                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();
                            if (iterationData)
                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();
                            instanceKey = currentKey;
                            return c;
                        },
                    };
                };
                children.slot = true;
            }
            else {
                // If we dont have any children, we still need to provide an object
                // instead of an empty array (which raises a warning in vue)
                children = () => ({});
            }
        }
        // Compile the for loop down
        if ('for' in node && node.for) {
            const values = node.for.length === 3 ? node.for[2] : node.for[1];
            const getValues = typeof values === 'string' && values.startsWith('$')
                ? provider(compile(values))
                : () => values;
            iterator = [
                getValues,
                node.for[0],
                node.for.length === 3 ? String(node.for[1]) : null,
            ];
        }
        return [condition, element, attrs, children, alternate, iterator, resolve];
    }
    /**
     * Given a particular function that produces children, ensure that the second
     * argument of all these slots is the original instance key being used to
     * render the slots.
     * @param children - The children() function that will produce slots
     */
    function createSlots(children, iterationData) {
        const slots = children(iterationData);
        const currentKey = instanceKey;
        return Object.keys(slots).reduce((allSlots, slotName) => {
            const slotFn = slots && slots[slotName];
            allSlots[slotName] = (data) => {
                return (slotFn && slotFn(data, currentKey)) || null;
            };
            return allSlots;
        }, {});
    }
    /**
     * Creates an element
     * @param data - The context data available to the node
     * @param node - The schema node to render
     * @returns
     */
    function createElement(library, node) {
        // Parses the schema node into pertinent parts
        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);
        // This is a sub-render function (called within a render function). It must
        // only use pre-compiled features, and be organized in the most efficient
        // manner possible.
        let createNodes = ((iterationData) => {
            if (condition && element === null && children) {
                // Handle conditional if/then statements
                return condition()
                    ? children(iterationData)
                    : alternate && alternate(iterationData);
            }
            if (element && (!condition || condition())) {
                // handle text nodes
                if (element === 'text' && children) {
                    return createTextVNode(String(children()));
                }
                // Handle lone slots
                if (element === 'slot' && children)
                    return children(iterationData);
                // Handle resolving components
                const el = resolve ? resolveComponent(element) : element;
                // If we are rendering slots as children, ensure their instanceKey is properly added
                const slots = (children === null || children === void 0 ? void 0 : children.slot)
                    ? createSlots(children, iterationData)
                    : null;
                // Handle dom elements and components
                return h(el, attrs(), (slots || (children ? children(iterationData) : [])));
            }
            return typeof alternate === 'function'
                ? alternate(iterationData)
                : alternate;
        });
        if (iterator) {
            const repeatedNode = createNodes;
            const [getValues, valueName, keyName] = iterator;
            createNodes = (() => {
                const _v = getValues();
                const values = !isNaN(_v)
                    ? Array(Number(_v))
                        .fill(0)
                        .map((_, i) => i)
                    : _v;
                const fragment = [];
                if (typeof values !== 'object')
                    return null;
                const instanceScope = instanceScopes.get(instanceKey) || [];
                const isArray = Array.isArray(values);
                for (const key in values) {
                    if (isArray && key in Array.prototype)
                        continue; // Fix #299
                    const iterationData = Object.defineProperty({
                        ...instanceScope.reduce((previousIterationData, scopedData) => {
                            if (previousIterationData.__idata) {
                                return { ...previousIterationData, ...scopedData };
                            }
                            return scopedData;
                        }, {}),
                        [valueName]: values[key],
                        ...(keyName !== null
                            ? { [keyName]: isArray ? Number(key) : key }
                            : {}),
                    }, '__idata', { enumerable: false, value: true });
                    instanceScope.unshift(iterationData);
                    fragment.push(repeatedNode.bind(null, iterationData)());
                    instanceScope.shift();
                }
                return fragment;
            });
        }
        return createNodes;
    }
    /**
     * Given a schema, parse it and return the resulting renderable nodes.
     * @param data - The schema context object
     * @param library - The available components
     * @param node - The node to parse
     * @returns
     */
    function createElements(library, schema) {
        if (Array.isArray(schema)) {
            const els = schema.map(createElement.bind(null, library));
            return (iterationData) => els.map((element) => element(iterationData));
        }
        // Single node to render
        const element = createElement(library, schema);
        return (iterationData) => element(iterationData);
    }
    /**
     * Data providers produced as a result of the compiler.
     */
    const providers = [];
    /**
     * Append the requisite compiler provider and return the compiled function.
     * @param compiled - A compiled function
     * @returns
     */
    function provider(compiled, hints = {}) {
        const compiledFns = {};
        providers.push((callback, key) => {
            compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));
        });
        return () => compiledFns[instanceKey]();
    }
    /**
     * Creates a new instance of a given schema — this either comes from a
     * memoized copy of the parsed schema or a freshly parsed version. An symbol
     * instance key, and dataProvider functions are passed in.
     * @param providerCallback - A function that is called for each required provider
     * @param key - a symbol representing the current instance
     */
    return function createInstance(providerCallback, key) {
        const memoKey = JSON.stringify(schema);
        const [render, compiledProviders] = has(memo, memoKey)
            ? memo[memoKey]
            : [createElements(library, schema), providers];
        memo[memoKey] = [render, compiledProviders];
        compiledProviders.forEach((compiledProvider) => {
            compiledProvider(providerCallback, key);
        });
        return () => {
            instanceKey = key;
            return render();
        };
    };
}
/**
 * Checks the current runtime scope for data.
 * @param token - The token to lookup in the current scope
 * @param defaultValue - The default ref value to use if no scope is found.
 */
function useScope(token, defaultValue) {
    const scopedData = instanceScopes.get(instanceKey) || [];
    let scopedValue = undefined;
    if (scopedData.length) {
        scopedValue = getValue(scopedData, token.split('.'));
    }
    return scopedValue === undefined ? defaultValue : scopedValue;
}
/**
 * Get the current scoped data and flatten it.
 */
function slotData(data, key) {
    return new Proxy(data, {
        get(...args) {
            let data = undefined;
            const property = args[1];
            if (typeof property === 'string') {
                const prevKey = instanceKey;
                instanceKey = key;
                data = useScope(property, undefined);
                instanceKey = prevKey;
            }
            return data !== undefined ? data : Reflect.get(...args);
        },
    });
}
/**
 * Provides data to a parsed schema.
 * @param provider - The SchemaProvider (output of calling parseSchema)
 * @param data - Data to fetch values from
 * @returns
 */
function createRenderFn(instanceCreator, data, instanceKey) {
    return instanceCreator((requirements, hints = {}) => {
        return requirements.reduce((tokens, token) => {
            if (token.startsWith('slots.')) {
                const slot = token.substring(6);
                const hasSlot = data.slots && has(data.slots, slot);
                if (hints.if) {
                    // If statement — dont render the slot, check if it exists
                    tokens[token] = () => hasSlot;
                }
                else if (data.slots && hasSlot) {
                    // Render the slot with current scope data
                    const scopedData = slotData(data, instanceKey);
                    tokens[token] = () => data.slots[slot](scopedData);
                    return tokens;
                }
            }
            const value = getRef(token, data);
            tokens[token] = () => useScope(token, value.value);
            return tokens;
        }, {});
    }, instanceKey);
}
let i = 0;
/**
 * The FormKitSchema vue component:
 * @public
 */
const FormKitSchema = defineComponent({
    name: 'FormKitSchema',
    props: {
        schema: {
            type: [Array, Object],
            required: true,
        },
        data: {
            type: Object,
            default: () => ({}),
        },
        library: {
            type: Object,
            default: () => ({}),
        },
    },
    setup(props, context) {
        const instance = getCurrentInstance();
        let instanceKey = Symbol(String(i++));
        instanceScopes.set(instanceKey, []);
        let provider = parseSchema(props.library, props.schema);
        let render;
        let data;
        // Re-parse the schema if it changes:
        watch(() => props.schema, (newSchema, oldSchema) => {
            var _a;
            instanceKey = Symbol(String(i++));
            provider = parseSchema(props.library, props.schema);
            render = createRenderFn(provider, data, instanceKey);
            if (newSchema === oldSchema) {
                ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();
            }
        }, { deep: true });
        // Watch the data object explicitly
        watchEffect(() => {
            data = Object.assign(reactive(props.data), {
                slots: context.slots,
            });
            render = createRenderFn(provider, data, instanceKey);
        });
        return () => render();
    },
});

/**
 * All the explicit FormKit props.
 */
const nativeProps = {
    config: {
        type: Object,
        default: {},
    },
    classes: {
        type: Object,
        required: false,
    },
    delay: {
        type: Number,
        required: false,
    },
    errors: {
        type: Array,
        default: [],
    },
    inputErrors: {
        type: Object,
        default: () => ({}),
    },
    index: {
        type: Number,
        required: false,
    },
    id: {
        type: String,
        required: false,
    },
    modelValue: {
        required: false,
    },
    name: {
        type: String,
        required: false,
    },
    parent: {
        type: Object,
        required: false,
    },
    plugins: {
        type: Array,
        default: [],
    },
    sectionsSchema: {
        type: Object,
        default: {},
    },
    type: {
        type: [String, Object],
        default: 'text',
    },
    validation: {
        type: [String, Array],
        required: false,
    },
    validationMessages: {
        type: Object,
        required: false,
    },
    validationRules: {
        type: Object,
        required: false,
    },
    validationLabel: {
        type: [String, Function],
        required: false,
    },
};
/**
 * The FormKit props object.
 * @internal
 */
const props = nativeProps;

/**
 * The symbol that represents the formkit parent injection value.
 * @public
 */
const parentSymbol = Symbol('FormKitParent');
/**
 * The root FormKit component.
 * @public
 */
const FormKit = defineComponent({
    props,
    emits: {
        /* eslint-disable @typescript-eslint/no-unused-vars */
        input: (_value, _node) => true,
        inputRaw: (_value, _node) => true,
        'update:modelValue': (_value) => true,
        node: (node) => !!node,
        submit: (_data, _node) => true,
        submitRaw: (_event, _node) => true,
        submitInvalid: (_node) => true,
        /* eslint-enable @typescript-eslint/no-unused-vars */
    },
    inheritAttrs: false,
    setup(props, context) {
        const node = useInput(props, context);
        if (!node.props.definition)
            error(600, node);
        if (node.props.definition.component) {
            return () => {
                var _a;
                return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {
                    context: node.context,
                }, { ...context.slots });
            };
        }
        const schema = ref([]);
        const generateSchema = () => {
            var _a, _b;
            const schemaDefinition = (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.schema;
            if (!schemaDefinition)
                error(601, node);
            schema.value =
                typeof schemaDefinition === 'function'
                    ? schemaDefinition({ ...props.sectionsSchema })
                    : schemaDefinition;
        };
        generateSchema();
        // If someone emits the schema event, we re-generate the schema
        node.on('schema', generateSchema);
        context.emit('node', node);
        const library = node.props.definition.library;
        // Expose the FormKitNode to template refs.
        context.expose({ node });
        return () => h(FormKitSchema, { schema: schema.value, data: node.context, library }, { ...context.slots });
    },
});

/**
 * The Create a new instance of the FormKit plugin for Vue.
 * @param app - A Vue application
 * @param config - FormKit Vue plugin configuration options
 */
function createPlugin(app, options) {
    app
        .component(options.alias || 'FormKit', FormKit)
        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);
    return {
        get: getNode,
        setLocale: (locale) => {
            var _a;
            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {
                options.config.rootConfig.locale = locale;
            }
        },
        clearErrors,
        setErrors,
        submit: submitForm,
        reset,
    };
}
/**
 * The symbol key for accessing the FormKit node options.
 * @public
 */
const optionsSymbol = Symbol.for('FormKitOptions');
/**
 * The symbol key for accessing FormKit root configuration.
 * @public
 */
const configSymbol = Symbol.for('FormKitConfig');
/**
 * Create the FormKit plugin.
 * @public
 */
const plugin = {
    install(app, _options) {
        /**
         * Extend the default configuration options.
         */
        const options = Object.assign({
            alias: 'FormKit',
            schemaAlias: 'FormKitSchema',
        }, typeof _options === 'function' ? _options() : _options);
        /**
         * The root configuration options.
         */
        const rootConfig = createConfig(options.config || {});
        /**
         * We dont want to explicitly provide any "config" options, only a root
         * config option — so here we override the existing config options.
         */
        options.config = { rootConfig };
        /**
         * Register the global $formkit plugin property.
         */
        app.config.globalProperties.$formkit = createPlugin(app, options);
        /**
         * Provide the config to the application for injection.
         */
        app.provide(optionsSymbol, options);
        /**
         * Provide the root config to the application.
         */
        app.provide(configSymbol, rootConfig);
    },
};

/**
 * Indicates that the path that was requested is no longer valid in the object.
 */
const invalidGet = Symbol();
/**
 *
 * @param obj - An object to observe at depth
 * @param callback - A callback that
 * @public
 */
function watchVerbose(obj, callback) {
    const watchers = {};
    const applyWatch = (paths) => {
        // Watch each property
        for (const path of paths) {
            // Stops pre-existing watchers at a given location to prevent dupes:
            if (path.__str in watchers)
                watchers[path.__str]();
            watchers[path.__str] = watch(touch.bind(null, obj, path), dispatcher.bind(null, path), { deep: false });
        }
    };
    /**
     * Clear any watchers deeper than this path.
     * @param path - The path to start from
     */
    const clearWatch = (path) => {
        if (!path.length)
            return;
        for (const key in watchers) {
            if (`${key}`.startsWith(`${path.__str}.`)) {
                watchers[key]();
                delete watchers[key];
            }
        }
    };
    const dispatcher = createDispatcher(obj, callback, applyWatch, clearWatch);
    applyWatch(getPaths(obj));
}
/**
 * This function synchronously dispatches to the watch callbacks. It uses the
 * knowledge that the getPath function is a depth-first-search thus lower
 * specificity (lower tree nodes) will always have their watchers called first.
 * If a lower specificity watcher is triggered we want to ignore the higher
 * specificity watcher.
 * @param obj - The object to dispatch
 * @param callback - The callback function to emit
 * @param applyWatch - A way to apply watchers to update objects
 * @returns
 */
function createDispatcher(obj, callback, applyWatch, clearChildWatches) {
    // let dispatchedPaths: Record<string, ObjectPath> = {}
    // let clear: Promise<void> | null = null
    return (path) => {
        const value = get(obj, path);
        if (value === invalidGet)
            return;
        if (path.__deep)
            clearChildWatches(path);
        if (typeof value === 'object')
            applyWatch(getPaths(value, [path], ...path));
        callback(path, value, obj);
    };
}
/**
 * "Touches" a given property for reactivity tracking purposes, if the value at
 * the given path is an object, we flatten it to just its keys since we will
 * already be tracking sub properties independently.
 * @param obj - A ref to traverse for a given path
 * @param path - An array of strings representing the path to locate
 * @returns
 */
function touch(obj, path) {
    const value = get(obj, path);
    return value && typeof value === 'object' ? Object.keys(value) : value;
}
/**
 * "Touches" a given property for reactivity tracking purposes.
 * @param obj - A ref to traverse for a given path
 * @param path - An array of strings representing the path to locate
 * @returns
 */
function get(obj, path) {
    if (isRef(obj)) {
        if (path.length === 0)
            return obj.value;
        obj = obj.value;
    }
    return path.reduce((value, segment) => {
        if (value === invalidGet)
            return value;
        if (value === null || typeof value !== 'object') {
            return invalidGet;
        }
        return value[segment];
    }, obj);
}
/**
 * Recursively retrieves all enumerable property paths from the origination
 * object. For example:
 * ```js
 * const obj = {
 *   a: {
 *     b: 123
 *   },
 *   c: 567
 * }
 * const paths = getPaths(obj)
 * // [
 * //   ['a'],
 * //   ['a', 'b'],
 * //   ['c']
 * // ]
 * ```
 * @param obj - An object to retrieve paths for.
 * @param parents - An array of parent paths.
 * @returns
 * @internal
 */
function getPaths(obj, paths = [], ...parents) {
    if (obj === null)
        return paths;
    if (!parents.length) {
        const path = Object.defineProperty([], '__str', {
            value: '',
        });
        obj = isRef(obj) ? obj.value : obj;
        if (obj && typeof obj === 'object') {
            Object.defineProperty(path, '__deep', { value: true });
            paths.push(path);
        }
        else {
            return [path];
        }
    }
    if (obj === null || typeof obj !== 'object')
        return paths;
    for (const key in obj) {
        const path = parents.concat(key);
        Object.defineProperty(path, '__str', { value: path.join('.') });
        const value = obj[key];
        if (isPojo(value) || Array.isArray(value)) {
            paths.push(Object.defineProperty(path, '__deep', { value: true }));
            paths = paths.concat(getPaths(value, [], ...path));
        }
        else {
            paths.push(path);
        }
    }
    return paths;
}

/**
 * Gets the raw underlying target object from a Vue Ref or Reactive object.
 * @param obj - Get the underlying target object, or no-op.
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function useRaw(obj) {
    if (obj === null || typeof obj !== 'object')
        return obj;
    if (isReactive(obj)) {
        obj = toRaw(obj);
    }
    else if (isRef(obj)) {
        obj = (isReactive(obj.value) ? useRaw(obj.value) : obj.value);
    }
    return obj;
}

/**
 * Props that are extracted from the attrs object.
 * TODO: Currently local, this should probably exported to a inputs or another
 * package.
 */
const pseudoProps = [
    'help',
    'label',
    'ignore',
    'disabled',
    'preserve',
    /^preserve(-e|E)rrors/,
    /^[a-z]+(?:-visibility|Visibility)$/,
    /^[a-zA-Z-]+(?:-class|Class)$/,
    'prefixIcon',
    'suffixIcon',
    /^[a-zA-Z-]+(?:-icon|Icon)$/,
];
/**
 * Given some props, map those props to individualized props internally.
 * @param node - A formkit node
 * @param props - Some props that may include a classes object
 */
function classesToNodeProps(node, props) {
    if (props.classes) {
        Object.keys(props.classes).forEach((key) => {
            if (typeof key === 'string') {
                node.props[`_${key}Class`] = props.classes[key];
                // We need to ensure Vue is aware that we want to actually observe the
                // child values too, so we touch them here.
                if (isObject(props.classes[key]) && key === 'inner')
                    Object.values(props.classes[key]);
            }
        });
    }
}
/**
 * Extracts known FormKit listeners.
 * @param props - Extract known FormKit listeners.
 * @returns
 */
function onlyListeners(props) {
    if (!props)
        return {};
    const knownListeners = ['Submit', 'SubmitRaw', 'SubmitInvalid'].reduce((listeners, listener) => {
        const name = `on${listener}`;
        if (name in props) {
            if (typeof props[name] === 'function') {
                listeners[name] = props[name];
            }
        }
        return listeners;
    }, {});
    return knownListeners;
}
/**
 * A composable for creating a new FormKit node.
 * @param type - The type of node (input, group, list)
 * @param attrs - The FormKit "props" — which is really the attrs list.
 * @returns
 * @public
 */
function useInput(props, context, options = {}) {
    /**
     * The configuration options, these are provided by either the plugin or by
     * explicit props.
     */
    const config = Object.assign({}, inject(optionsSymbol) || {}, options);
    /**
     * The current instance.
     */
    const instance = getCurrentInstance();
    /**
     * Extracts the listeners.
     */
    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);
    /**
     * Determines if the prop is v-modeled.
     */
    const isVModeled = props.modelValue !== undefined;
    /**
     * Determines if the object being passed as a v-model is reactive.
     */
    // const isReactiveVModel = isVModeled && isReactive(props.modelValue)
    /**
     * Define the initial component
     */
    const value = props.modelValue !== undefined
        ? props.modelValue
        : cloneAny(context.attrs.value);
    /**
     * Creates the node's initial props from the context, props, and definition
     * @returns
     */
    function createInitialProps() {
        const initialProps = {
            ...nodeProps(props),
            ...listeners,
        };
        const attrs = except(nodeProps(context.attrs), pseudoProps);
        if (!attrs.key)
            attrs.key = token();
        initialProps.attrs = attrs;
        const propValues = only(nodeProps(context.attrs), pseudoProps);
        for (const propName in propValues) {
            initialProps[camel(propName)] = propValues[propName];
        }
        const classesProps = { props: {} };
        classesToNodeProps(classesProps, props);
        Object.assign(initialProps, classesProps.props);
        if (typeof initialProps.type !== 'string') {
            initialProps.definition = initialProps.type;
            delete initialProps.type;
        }
        return initialProps;
    }
    /**
     * Create the FormKitNode.
     */
    const initialProps = createInitialProps();
    /**
     * The parent node.
     */
    const parent = initialProps.ignore
        ? null
        : props.parent || inject(parentSymbol, null);
    const node = createNode(extend(config || {}, {
        name: props.name || undefined,
        value,
        parent,
        plugins: (config.plugins || []).concat(props.plugins),
        config: props.config,
        props: initialProps,
        index: props.index,
    }, false, true));
    /**
     * If no definition has been assigned at this point — we're out!
     */
    if (!node.props.definition)
        error(600, node);
    /**
     * All props that are bound "late" (after node creation) — are added to a set
     * which is used to watch the context.attrs object.
     */
    const lateBoundProps = ref(new Set(node.props.definition.props || []));
    /**
     * Any additional props added at a "later" time should also be part of the
     * late bound props.
     */
    node.on('added-props', ({ payload: lateProps }) => {
        if (Array.isArray(lateProps))
            lateProps.forEach((newProp) => lateBoundProps.value.add(newProp));
    });
    /**
     * These prop names must be assigned.
     */
    const pseudoPropNames = computed(() => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {
        if (typeof prop === 'string') {
            names.push(camel(prop));
            names.push(kebab(prop));
        }
        else {
            names.push(prop);
        }
        return names;
    }, []));
    /* Splits Classes object into discrete props for each key */
    watchEffect(() => classesToNodeProps(node, props));
    /**
     * The props object already has properties even if they start as "undefined"
     * so we can loop over them and individual watchEffect to prevent responding
     * inappropriately.
     */
    const passThrough = nodeProps(props);
    for (const prop in passThrough) {
        watch(() => props[prop], () => {
            if (props[prop] !== undefined) {
                node.props[prop] = props[prop];
            }
        });
    }
    /**
     * Watch "pseudoProp" attributes explicitly.
     */
    const attributeWatchers = new Set();
    const possibleProps = nodeProps(context.attrs);
    watchEffect(() => {
        watchAttributes(only(possibleProps, pseudoPropNames.value));
    });
    /**
     * Defines attributes that should be used as props.
     * @param attrProps - Attributes that should be used as props instead
     */
    function watchAttributes(attrProps) {
        attributeWatchers.forEach((stop) => {
            stop();
            attributeWatchers.delete(stop);
        });
        for (const prop in attrProps) {
            const camelName = camel(prop);
            attributeWatchers.add(watch(() => context.attrs[prop], () => {
                node.props[camelName] = context.attrs[prop];
            }));
        }
    }
    /**
     * Watch and dynamically set attribute values, those values that are not
     * props and are not pseudoProps
     */
    watchEffect(() => {
        const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);
        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);
    });
    /**
     * Add any/all "prop" errors to the store.
     */
    watchEffect(() => {
        const messages = props.errors.map((error) => createMessage({
            key: slugify(error),
            type: 'error',
            value: error,
            meta: { source: 'prop' },
        }));
        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');
    });
    /**
     * Add input errors.
     */
    if (node.type !== 'input') {
        const sourceKey = `${node.name}-prop`;
        watchEffect(() => {
            const keys = Object.keys(props.inputErrors);
            if (!keys.length)
                node.clearErrors(true, sourceKey);
            const messages = keys.reduce((messages, key) => {
                let value = props.inputErrors[key];
                if (typeof value === 'string')
                    value = [value];
                if (Array.isArray(value)) {
                    messages[key] = value.map((error) => createMessage({
                        key: error,
                        type: 'error',
                        value: error,
                        meta: { source: sourceKey },
                    }));
                }
                return messages;
            }, {});
            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);
        });
    }
    /**
     * Watch the config prop for any changes.
     */
    watchEffect(() => Object.assign(node.config, props.config));
    /**
     * Produce another parent object.
     */
    if (node.type !== 'input') {
        provide(parentSymbol, node);
    }
    let inputTimeout;
    // eslint-disable-next-line @typescript-eslint/ban-types
    const mutex = new WeakSet();
    /**
     * Explicitly watch the input value, and emit changes (lazy)
     */
    node.on('modelUpdated', () => {
        var _a, _b;
        // Emit the values after commit
        context.emit('inputRaw', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value, node);
        clearTimeout(inputTimeout);
        inputTimeout = setTimeout(context.emit, 20, 'input', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value, node);
        if (isVModeled && node.context) {
            const newValue = useRaw(node.context.value);
            if (isObject(newValue) && useRaw(props.modelValue) !== newValue) {
                // If this is an object that has been mutated inside FormKit core then
                // we know when it is emitted it will "return" in the watchVerbose so
                // we pro-actively add it to the mutex.
                mutex.add(newValue);
            }
            context.emit('update:modelValue', newValue);
        }
    });
    /**
     * Enabled support for v-model, using this for groups/lists is not recommended
     */
    if (isVModeled) {
        watchVerbose(toRef(props, 'modelValue'), (path, value) => {
            var _a;
            const rawValue = useRaw(value);
            if (isObject(rawValue) && mutex.has(rawValue)) {
                return mutex.delete(rawValue);
            }
            if (!path.length)
                node.input(value, false);
            else
                (_a = node.at(path)) === null || _a === void 0 ? void 0 : _a.input(value, false);
        });
        /**
         * On initialization, if the node’s value was updated (like in a plugin
         * hook) then we should emit a `modelUpdated` event.
         */
        if (node.value !== value) {
            node.emit('modelUpdated');
        }
    }
    /**
     * When this input shuts down, we need to "delete" the node too.
     */
    // onUnmounted(() => node.destroy())
    onBeforeUnmount(() => node.destroy());
    return node;
}

let totalCreated = 1;
/**
 * Determine if the given object is a vue component.
 *
 * @param obj - Object or function
 * @returns
 * @public
 */
function isComponent(obj) {
    return ((typeof obj === 'function' && obj.length === 2) ||
        (typeof obj === 'object' &&
            !Array.isArray(obj) &&
            !('$el' in obj) &&
            !('$cmp' in obj) &&
            !('if' in obj)));
}
/**
 * Creates a new input from schema or a Vue component with the "standard"
 * FormKit features in place such as labels, help text, validation messages, and
 * class support.
 *
 * @param schemaOrComponent - The actual schema of the input.
 * @public
 */
function createInput(schemaOrComponent, definitionOptions = {}) {
    const definition = {
        type: 'input',
        ...definitionOptions,
    };
    let schema;
    if (isComponent(schemaOrComponent)) {
        const cmpName = `SchemaComponent${totalCreated++}`;
        schema = createSection('input', () => ({
            $cmp: cmpName,
            props: {
                context: '$node.context',
            },
        }));
        definition.library = { [cmpName]: markRaw(schemaOrComponent) };
    }
    else if (typeof schemaOrComponent === 'function') {
        schema = schemaOrComponent;
    }
    else {
        schema = createSection('input', () => cloneAny(schemaOrComponent));
    }
    // Use the default wrapping schema
    definition.schema = useSchema(schema || 'Schema undefined');
    return definition;
}

/**
 * A plugin that creates Vue-specific context object on each given node.
 * @param node - FormKitNode to create the context on.
 * @public
 */
const vueBindings = function vueBindings(node) {
    /**
     * Start a validity counter on all blocking messages.
     */
    node.ledger.count('blocking', (m) => m.blocking);
    const isValid = ref(!node.ledger.value('blocking'));
    /**
     * Start an error message counter.
     */
    node.ledger.count('errors', (m) => m.type === 'error');
    const hasErrors = ref(!!node.ledger.value('errors'));
    /**
     * Keep track of the first time a Vue tick cycle has passed.
     */
    let hasTicked = false;
    nextTick(() => {
        hasTicked = true;
    });
    /**
     * All messages with the visibility state set to true.
     */
    const availableMessages = reactive(node.store.reduce((store, message) => {
        if (message.visible) {
            store[message.key] = message;
        }
        return store;
    }, {}));
    /**
     * A flag that determines when validation messages should be displayed.
     */
    const validationVisibility = ref(node.props.validationVisibility || 'blur');
    node.on('prop:validationVisibility', ({ payload }) => {
        validationVisibility.value = payload;
    });
    /**
     * Keep track of if this input has ever shown validation errors.
     */
    const hasShownErrors = ref(validationVisibility.value === 'live');
    /**
     * The current visibility state of validation messages.
     */
    const validationVisible = computed(() => {
        if (context.state.submitted)
            return true;
        if (!hasShownErrors.value && !context.state.settled) {
            return false;
        }
        switch (validationVisibility.value) {
            case 'live':
                return true;
            case 'blur':
                return context.state.blurred;
            case 'dirty':
                return context.state.dirty;
            default:
                return false;
        }
    });
    /**
     * Determines if the input should be considered "complete".
     */
    const isComplete = computed(() => {
        return hasValidation.value
            ? isValid.value && !hasErrors.value
            : context.state.dirty && !empty(context.value);
    });
    /**
     * If the input has validation rules or not.
     */
    const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);
    node.on('prop:parsedRules', ({ payload: rules }) => {
        hasValidation.value = Array.isArray(rules) && rules.length > 0;
    });
    /**
     * All messages that are currently on display to an end user. This changes
     * based on the current message type visibility, like errorVisibility.
     */
    const messages = computed(() => {
        const visibleMessages = {};
        for (const key in availableMessages) {
            const message = availableMessages[key];
            if (message.type !== 'validation' || validationVisible.value) {
                visibleMessages[key] = message;
            }
        }
        return visibleMessages;
    });
    /**
     * UI Messages.
     */
    const ui = reactive(node.store.reduce((messages, message) => {
        if (message.type === 'ui' && message.visible)
            messages[message.key] = message;
        return messages;
    }, {}));
    /**
     * This is the reactive data object that is provided to all schemas and
     * forms. It is a subset of data in the core node object.
     */
    const cachedClasses = reactive({});
    const classes = new Proxy(cachedClasses, {
        get(...args) {
            const [target, property] = args;
            let className = Reflect.get(...args);
            if (!className && typeof property === 'string') {
                if (!has(target, property) && !property.startsWith('__v')) {
                    const observedNode = createObserver(node);
                    observedNode.watch((node) => {
                        const rootClasses = typeof node.config.rootClasses === 'function'
                            ? node.config.rootClasses(property, node)
                            : {};
                        const globalConfigClasses = node.config.classes
                            ? createClasses(property, node, node.config.classes[property])
                            : {};
                        const classesPropClasses = createClasses(property, node, node.props[`_${property}Class`]);
                        const sectionPropClasses = createClasses(property, node, node.props[`${property}Class`]);
                        className = generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);
                        target[property] = className;
                    });
                }
            }
            return className;
        },
    });
    const describedBy = computed(() => {
        const describers = [];
        if (context.help) {
            describers.push(`help-${node.props.id}`);
        }
        for (const key in messages.value) {
            describers.push(`${node.props.id}-${key}`);
        }
        return describers.length ? describers.join(' ') : undefined;
    });
    const value = ref(node.value);
    const _value = ref(node.value);
    const context = reactive({
        _value,
        attrs: node.props.attrs,
        disabled: node.props.disabled,
        describedBy,
        fns: {
            length: (obj) => Object.keys(obj).length,
            number: (value) => Number(value),
            string: (value) => String(value),
            json: (value) => JSON.stringify(value),
            eq,
        },
        handlers: {
            blur: (e) => {
                node.store.set(createMessage({ key: 'blurred', visible: false, value: true }));
                if (typeof node.props.attrs.onBlur === 'function') {
                    node.props.attrs.onBlur(e);
                }
            },
            touch: () => {
                node.store.set(createMessage({ key: 'dirty', visible: false, value: true }));
            },
            DOMInput: (e) => {
                node.input(e.target.value);
                node.emit('dom-input-event', e);
            },
        },
        help: node.props.help,
        id: node.props.id,
        label: node.props.label,
        messages,
        node: markRaw(node),
        options: node.props.options,
        state: {
            blurred: false,
            complete: isComplete,
            dirty: false,
            submitted: false,
            settled: node.isSettled,
            valid: isValid,
            errors: hasErrors,
            rules: hasValidation,
            validationVisible,
        },
        type: node.props.type,
        family: node.props.family,
        ui,
        value,
        classes,
    });
    /**
     * Ensure the context object is properly configured after booting up.
     */
    node.on('created', () => {
        if (!eq(context.value, node.value)) {
            _value.value = node.value;
            value.value = node.value;
            triggerRef(value);
            triggerRef(_value);
        }
        node.props._init = cloneAny(node.value);
    });
    /**
     * Sets the settled state.
     */
    node.on('settled', ({ payload: isSettled }) => {
        context.state.settled = isSettled;
    });
    /**
     * Observes node.props properties explicitly and updates them in the context
     * object.
     * @param observe - Props to observe and register as context data.
     */
    function observeProps(observe) {
        observe.forEach((prop) => {
            prop = camel(prop);
            if (!has(context, prop) && has(node.props, prop)) {
                context[prop] = node.props[prop];
            }
            node.on(`prop:${prop}`, ({ payload }) => {
                context[prop] = payload;
            });
        });
    }
    /**
     * We use a node observer to individually observe node props.
     */
    const rootProps = () => {
        const props = [
            'help',
            'label',
            'disabled',
            'options',
            'type',
            'attrs',
            'preserve',
            'preserveErrors',
            'id',
        ];
        const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;
        const matchingProps = Object.keys(node.props).filter((prop) => {
            return iconPattern.test(prop);
        });
        return props.concat(matchingProps);
    };
    observeProps(rootProps());
    /**
     * Once the input is defined, deal with it.
     * @param definition - Type definition.
     */
    function definedAs(definition) {
        if (definition.props)
            observeProps(definition.props);
    }
    node.props.definition && definedAs(node.props.definition);
    /**
     * When new props are added to the core node as "props" (ie not attrs) then
     * we automatically need to start tracking them here.
     */
    node.on('added-props', ({ payload }) => observeProps(payload));
    /**
     * Watch for input events from core.
     */
    node.on('input', ({ payload }) => {
        if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {
            _value.value = shallowClone(payload);
        }
        else {
            _value.value = payload;
            triggerRef(_value);
        }
    });
    /**
     * Watch for input commits from core.
     */
    node.on('commit', ({ payload }) => {
        if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {
            value.value = _value.value = shallowClone(payload);
        }
        else {
            value.value = _value.value = payload;
            triggerRef(value);
        }
        node.emit('modelUpdated');
        // The input is dirty after a value has been input by a user
        if (!context.state.dirty &&
            node.isCreated &&
            hasTicked &&
            !eq(value.value, node.props._init))
            context.handlers.touch();
        if (isComplete &&
            node.type === 'input' &&
            hasErrors.value &&
            !undefine(node.props.preserveErrors)) {
            node.store.filter((message) => { var _a; return !(message.type === 'error' && ((_a = message.meta) === null || _a === void 0 ? void 0 : _a.autoClear) === true); });
        }
    });
    /**
     * Update the local state in response to messages.
     * @param message - A formkit message
     */
    const updateState = async (message) => {
        if (message.type === 'ui' &&
            message.visible &&
            !message.meta.showAsMessage) {
            ui[message.key] = message;
        }
        else if (message.visible) {
            availableMessages[message.key] = message;
        }
        else if (message.type === 'state') {
            // await node.settled
            context.state[message.key] = !!message.value;
        }
    };
    /**
     * Listen to message events and modify the local message data values.
     */
    node.on('message-added', (e) => updateState(e.payload));
    node.on('message-updated', (e) => updateState(e.payload));
    node.on('message-removed', ({ payload: message }) => {
        delete ui[message.key];
        delete availableMessages[message.key];
        delete context.state[message.key];
    });
    node.on('settled:blocking', () => {
        isValid.value = true;
    });
    node.on('unsettled:blocking', () => {
        isValid.value = false;
    });
    node.on('settled:errors', () => {
        hasErrors.value = false;
    });
    node.on('unsettled:errors', () => {
        hasErrors.value = true;
    });
    /**
     * Watch the validation visible prop and set the hasShownErrors state.
     */
    watch(validationVisible, (value) => {
        if (value) {
            hasShownErrors.value = true;
        }
    });
    node.context = context;
    // The context is complete
    node.emit('context', node, false);
};

/**
 * Default configuration options. Includes all validation rules,
 * en i18n messages.
 * @public
 */
const defaultConfig = (options = {}) => {
    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, theme = undefined, iconLoaderUrl = undefined, iconLoader = undefined, icons = {}, ...nodeOptions } = options;
    /**
     * The default configuration includes the validation plugin,
     * with all core-available validation rules.
     */
    const validation = createValidationPlugin({
        ...defaultRules,
        ...(rules || {}),
    });
    /**
     * Includes the i18n plugin with only the english language
     * messages.
     */
    const i18n = createI18nPlugin(extend({ en, ...(locales || {}) }, messages));
    /**
     * Create the library of inputs that are generally available. This default
     * config imports all "native" inputs by default, but
     */
    const library = createLibraryPlugin(inputs, inputs$1);
    /**
     * Create the theme plugin for the user provided theme
     */
    const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);
    return extend({
        plugins: [library, themePlugin, vueBindings, i18n, validation],
        ...(!locale ? {} : { config: { locale } }),
    }, nodeOptions || {}, true);
};

/**
 * Renders an icon using the current IconLoader set at the root FormKit config
 * @public
 */
const FormKitIcon = defineComponent({
    name: 'FormKitIcon',
    props: {
        icon: {
            type: String,
            default: ''
        },
        iconLoader: {
            type: Function,
            default: null
        },
        iconLoaderUrl: {
            type: Function,
            default: null
        }
    },
    setup(props) {
        var _a, _b;
        const icon = ref(undefined);
        const config = inject(optionsSymbol, {});
        const parent = inject(parentSymbol, null);
        let iconHandler = undefined;
        if (props.iconLoader && typeof props.iconLoader === 'function') {
            // if we have a locally supplied loader, then use it
            iconHandler = createIconHandler(props.iconLoader);
        }
        else if (parent && ((_a = parent.props) === null || _a === void 0 ? void 0 : _a.iconLoader)) {
            // otherwise try to inherit from a parent
            iconHandler = createIconHandler(parent.props.iconLoader);
        }
        else if (props.iconLoaderUrl && typeof props.iconLoaderUrl === 'function') {
            iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);
        }
        else {
            // grab our iconHandler from the global config
            const iconPlugin = (_b = config === null || config === void 0 ? void 0 : config.plugins) === null || _b === void 0 ? void 0 : _b.find(plugin => {
                return typeof plugin.iconHandler === 'function';
            });
            if (iconPlugin) {
                iconHandler = iconPlugin.iconHandler;
            }
        }
        if (iconHandler && typeof iconHandler === 'function') {
            const iconOrPromise = iconHandler(props.icon);
            if (iconOrPromise instanceof Promise) {
                iconOrPromise.then((iconValue) => {
                    icon.value = iconValue;
                });
            }
            else {
                icon.value = iconOrPromise;
            }
        }
        return () => {
            if (icon.value) {
                return h('span', {
                    class: 'formkit-icon',
                    innerHTML: icon.value
                });
            }
            return null;
        };
    }
});

export { FormKit, FormKitIcon, FormKitSchema, vueBindings as bindings, configSymbol, createInput, defaultConfig, optionsSymbol, parentSymbol, plugin, useInput, watchVerbose };
