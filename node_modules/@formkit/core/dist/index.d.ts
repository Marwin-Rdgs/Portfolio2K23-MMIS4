/**
 * Perform a breadth-first-search on a node subtree and locate the first
 * instance of a match.
 * @param node -
 * @param name -
 * @returns FormKitNode
 * @public
 */
export declare function bfs(tree: FormKitNode, searchValue: string | number, searchGoal?: keyof FormKitNode | FormKitSearchFunction): FormKitNode | undefined;

/**
 * Child messages that were not immediately applied due to the child not existing.
 */
declare type ChildMessageBuffer = Map<string, Array<[FormKitMessage[], MessageClearer | undefined]>>;

/**
 * Clears child errors.
 * @param id - The id of the node you want to clear errors for
 * @param clearChildren - Determines if the the children of this node should have their errors cleared.
 * @public
 */
export declare function clearErrors(id: string, clearChildren?: boolean): void;

/**
 * Compiles a logical string like "a != z || b == c" into a single function.
 * The return value is an object with a "provide" method that iterates over all
 * requirement tokens to use as replacements.
 * ```typescript
 * let name = {
 *   value: 'jon'
 * }
 * const condition = compile("$name == 'bob'").provide((token) => {
 *  return () => name.value // must return a function!
 * })
 *
 * condition() // false
 * ```
 * @param expr - A string to compile
 * @returns
 * @public
 */
export declare function compile(expr: string): FormKitCompilerOutput;

/**
 * Function that produces a standardized object representation of CSS classes
 * @param propertyKey - section key
 * @param node - FormKit node
 * @param sectionClassList - Things to turn into classes
 * @returns
 * @public
 */
export declare function createClasses(propertyKey: string, node: FormKitNode, sectionClassList?: FormKitClasses | string | Record<string, boolean>): Record<string, boolean>;

/**
 * Creates a new instance of a global configuration option. This object is
 * essentially just a FormKitOption object, but it can be used as the root for
 * FormKitConfig's proxy and retain event "emitting".
 *
 * @param options - FormKit node options to be used globally.
 * @public
 */
export declare function createConfig(options?: Partial<FormKitConfig>): FormKitRootConfig;

/**
 * Creates a new FormKitMessage object.
 * @param conf - The message configuration
 * @returns FormKitMessage
 * @public
 */
export declare function createMessage(conf: Partial<FormKitMessage>, node?: FormKitNode): FormKitMessageProps;

/**
 * Creates a new instance of a FormKit Node. Nodes are the atomic unit of
 * a FormKit graph.
 *
 * @param options - An object of options to define the node.
 * @returns FormKitNode
 * @public
 */
export declare function createNode(options?: FormKitOptions): FormKitNode;

/**
 * Creates the initial value for a node based on the options passed in and the
 * type of the input.
 * @param options -
 * @param type -
 * @returns
 * @internal
 */
export declare function createValue(options: FormKitOptions): unknown;

/**
 * Deregister a node from the registry.
 * @param node - A node to remove
 * @public
 */
export declare function deregister(node: FormKitNode): void;

/**
 * Emits an error, generally should result in an exception.
 * @param code - The integer error code.
 * @param data - Usually an object of information to include.
 * @public
 */
export declare function error(code: number, data?: any): never;

/**
 * FormKit's global error handler.
 * @public
 */
export declare const errorHandler: FormKitDispatcher<FormKitHandlerPayload>;

/**
 * Error messages.
 * @internal
 */
declare type ErrorMessages = string | string[] | Record<string, string | string[]>;

/**
 * The current version of FormKit at the time the package is published. Is replaced
 * as part of the publishing script.
 * @public
 */
export declare const FORMKIT_VERSION = "1.0.0-beta.12";

/**
 * Describes the path to a particular node from the top of the tree.
 * @public
 */
export declare type FormKitAddress = Array<string | number>;

/**
 * The possible value types of attributes (in the schema)
 * @public
 */
export declare type FormKitAttributeValue = string | number | boolean | undefined | FormKitSchemaAttributes | FormKitSchemaAttributesCondition;

/**
 * The callback type for node.each()
 * @public
 */
export declare interface FormKitChildCallback {
    (child: FormKitNode): any;
}

/**
 * A descriptor of a child value, generally passed up a node tree.
 * @public
 */
export declare interface FormKitChildValue {
    name: string | number | symbol;
    value: any;
    from?: number | symbol;
}

/**
 * Definition for a function that produces CSS classes
 * @public
 */
export declare interface FormKitClasses {
    (node: FormKitNode, sectionKey: string): string | Record<string, boolean>;
}

/**
 * The compiler output, a function that adds the required tokens.
 * @public
 */
export declare interface FormKitCompilerOutput {
    (tokens?: Record<string, any>): boolean | number | string;
    provide: FormKitCompilerProvider;
}

/**
 * A function that accepts a callback with a token as the only argument, and
 * must return a function that provides the true value of the token.
 * @public
 */
export declare type FormKitCompilerProvider = (callback: (requirements: string[]) => Record<string, () => any>) => FormKitCompilerOutput;

/**
 * General "app" like configuration options, these are automatically inherited
 * by all children — they are not reactive.
 * @public
 */
export declare interface FormKitConfig {
    delimiter: string;
    classes?: Record<string, FormKitClasses | string | Record<string, boolean>>;
    rootClasses: (sectionKey: string, node: FormKitNode) => Record<string, boolean>;
    rootConfig?: FormKitRootConfig;
    [index: string]: any;
}

/**
 * The interface of the a FormKit node's context object. A FormKit node is a
 * proxy of this object.
 * @public
 */
export declare interface FormKitContext {
    /**
     * A node’s internal disturbance counter.
     */
    _d: number;
    /**
     * A node’s internal event emitter.
     */
    _e: FormKitEventEmitter;
    /**
     * A node’s internal disturbance counter promise.
     */
    _resolve: ((value: unknown) => void) | false;
    /**
     * A node’s internal input timeout.
     */
    _tmo: number | false;
    /**
     * A node’s internal pre-commit value.
     */
    _value: unknown;
    /**
     * An array of child nodes (groups and lists)
     */
    children: Array<FormKitNode>;
    /**
     * Configuration state for a given tree.
     */
    config: FormKitConfig;
    /**
     * The context object of the current front end framework being used.
     */
    context?: FormKitFrameworkContext;
    /**
     * Set of hooks
     */
    hook: FormKitHooks;
    /**
     * Begins as false, set to true when the node is finished being created.
     */
    isCreated: boolean;
    /**
     * Boolean determines if the node is in a settled state or not.
     */
    isSettled: boolean;
    /**
     * A counting ledger for arbitrary message counters.
     */
    ledger: FormKitLedger;
    /**
     * The name of the input — should be treated as readonly.
     */
    name: string | symbol;
    /**
     * The parent of a node.
     */
    parent: FormKitNode | null;
    /**
     * A Set of plugins registered on this node that can be inherited by children.
     */
    plugins: Set<FormKitPlugin>;
    /**
     * An proxied object of props. These are typically provided by the adapter
     * of choice.
     */
    props: Partial<FormKitProps>;
    /**
     * A promise that resolves when an input is in a settled state.
     */
    settled: Promise<unknown>;
    /**
     * The internal node store.
     */
    store: FormKitStore;
    /**
     * The traps available to a node.
     */
    traps: FormKitTraps;
    /**
     * The type of node, should only be 'input', 'list', or 'group'.
     */
    type: FormKitNodeType;
    /**
     * The actual value of the node.
     */
    value: unknown;
}

/**
 * Define the most basic shape of a context object for type guards trying to
 * reason about a context's value.
 * @public
 */
export declare interface FormKitContextShape {
    type: FormKitNodeType;
    value: unknown;
    _value: unknown;
}

/**
 * The counter object used to perform instance counting within
 * a tree.
 * @public
 */
export declare interface FormKitCounter {
    condition: FormKitCounterCondition;
    count: number;
    name: string;
    node: FormKitNode;
    promise: Promise<void>;
    resolve: () => void;
}

/**
 * Ledger counters require a condition function that determines if a given
 * message applies to it or not.
 * @public
 */
export declare interface FormKitCounterCondition {
    (message: FormKitMessage): boolean;
}

/**
 * The FormKitDispatcher interface is responsible creating/running "hooks".
 * @public
 */
export declare interface FormKitDispatcher<T> {
    (dispatchable: FormKitMiddleware<T>): number;
    unshift: (dispatchable: FormKitMiddleware<T>) => number;
    remove: (dispatchable: FormKitMiddleware<T>) => void;
    dispatch: (payload: T) => T;
}

/**
 * The internal structure of a FormKitEvent
 * @public
 */
export declare interface FormKitEvent {
    payload: any;
    name: string;
    bubble: boolean;
    origin: FormKitNode;
}

/**
 * The FormKitEventEmitter definition.
 * @public
 */
export declare interface FormKitEventEmitter {
    (node: FormKitNode, event: FormKitEvent): void;
    on: (eventName: string, listener: FormKitEventListener) => string;
    off: (receipt: string) => void;
    pause: (node?: FormKitNode) => void;
    play: (node?: FormKitNode) => void;
}

/**
 * Event listener functions definition.
 * @public
 */
export declare interface FormKitEventListener {
    (event: FormKitEvent): void;
    receipt?: string;
}

/**
 * Defines a function that allows selectively overriding a given schema.
 * @public
 */
export declare interface FormKitExtendableSchemaRoot {
    (extensions: Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>): FormKitSchemaNode[];
}

/**
 * Context object to be created by and used by each respective UI framework. No
 * values are created or output by FormKitCore, but this interface
 * should be followed by each respective plugin.
 * @public
 */
export declare interface FormKitFrameworkContext {
    [index: string]: unknown;
    /**
     * The current "live" value of the input. Not debounced.
     */
    _value: any;
    /**
     * An object of attributes that (generally) should be applied to the root
     * <input> element.
     */
    attrs: Record<string, any>;
    /**
     * Classes to apply on the various sections.
     */
    classes: Record<string, string>;
    /**
     * Event handlers.
     */
    handlers: {
        blur: () => void;
        touch: () => void;
        DOMInput: (e: Event) => void;
    } & Record<string, (...args: any[]) => void>;
    /**
     * Utility functions, generally for use in the input’s schema.
     */
    fns: Record<string, (...args: any[]) => any>;
    /**
     * The help text of the input.
     */
    help?: string;
    /**
     * The unique id of the input. Should also be applied as the id attribute.
     * This is generally required for accessibility reasons.
     */
    id: string;
    /**
     * The label of the input.
     */
    label?: string;
    /**
     * A list of messages to be displayed on the input. Often these are validation
     * messages and error messages, but other `visible` core node messages do also
     * apply here. This object is only populated when the validation should be
     * actually displayed.
     */
    messages: Record<string, FormKitMessage>;
    /**
     * The core node of this input.
     */
    node: FormKitNode;
    /**
     * If this input type accepts options (like select lists and checkboxes) then
     * this will be populated with a properly structured list of options.
     */
    options?: Array<Record<string, any> & {
        label: string;
        value: any;
    }>;
    /**
     * A collection of state trackers/details about the input.
     */
    state: FormKitFrameworkContextState;
    /**
     * The type of input "text" or "select" (retrieved from node.props.type). This
     * is not the core node type (input, group, or list).
     */
    type: string;
    /**
     * The current committed value of the input. This is the value that should be
     * used for most use cases.
     */
    value: any;
}

/**
 * The state inside a node’s framework context. Usually used to track things
 * like blurred, and validity states.
 * @public
 */
export declare interface FormKitFrameworkContextState {
    /**
     * If the input has been blurred.
     */
    blurred: boolean;
    /**
     * True when these conditions are met:
     *
     * Either:
     * - The input has validation rules
     * - The validation rules are all passing
     * - There are no errors on the input
     * Or:
     * - The input has no validation rules
     * - The input has no errors
     * - The input is dirty and has a value
     *
     * This is not intended to be used on forms/groups/lists but instead on
     * individual inputs. Imagine placing a green checkbox next to each input
     * when the user filled it out correctly — thats what these are for.
     */
    complete: boolean;
    /**
     * If the input has had a value typed into it or a change made to it.
     */
    dirty: boolean;
    /**
     * If the input has explicit errors placed on it, or in the case of a group,
     * list, or form, this is true if any children have errors on them.
     */
    errors: boolean;
    /**
     * True when the input has validation rules. Has nothing to do with the
     * state of those validation rules.
     */
    rules: boolean;
    /**
     * True when the input has completed its internal debounce cycle and the
     * value was committed to the form.
     */
    settled: boolean;
    /**
     * If the form has been submitted.
     */
    submitted: boolean;
    /**
     * If the input (or group/form/list) is passing all validation rules. In
     * the case of groups, forms, and lists this includes the validation state
     * of all its children.
     */
    valid: boolean;
    /**
     * If the validation-visibility has been satisfied and any validation
     * messages should be displayed.
     */
    validationVisible: boolean;
    /**
     * Allow users to add their own arbitrary states.
     */
    [index: string]: boolean;
}

/**
 * FormKit inputs of type 'group' must have keyed values by default.
 * @public
 */
export declare interface FormKitGroupValue {
    [index: string]: unknown;
    __init?: boolean;
}

/**
 * Describes the data passing through the error and warning handlers.
 * @public
 */
export declare interface FormKitHandlerPayload {
    code: number;
    data: any;
    message?: string;
}

/**
 * The available hooks for middleware.
 * @public
 */
export declare interface FormKitHooks {
    classes: FormKitDispatcher<{
        property: string;
        classes: Record<string, boolean>;
    }>;
    commit: FormKitDispatcher<any>;
    error: FormKitDispatcher<string>;
    setErrors: FormKitDispatcher<{
        localErrors: ErrorMessages;
        childErrors?: ErrorMessages;
    }>;
    init: FormKitDispatcher<FormKitNode>;
    input: FormKitDispatcher<any>;
    submit: FormKitDispatcher<Record<string, any>>;
    message: FormKitDispatcher<FormKitMessage>;
    prop: FormKitDispatcher<{
        prop: string | symbol;
        value: any;
    }>;
    text: FormKitDispatcher<FormKitTextFragment>;
    schema: FormKitDispatcher<FormKitSchemaNode[] | FormKitSchemaCondition>;
}

/**
 * A registry of input messages that should be applied to children of the node
 * they are passed to — where the string key of the object is the address of
 * the node to apply the messages on and the value is the message itself.
 */
declare interface FormKitInputMessages {
    [address: string]: FormKitMessage[];
}

/**
 * The FormKit ledger, a general-purpose message counting service provided by
 * FormKit core for counting messages throughout a tree.
 * @public
 */
export declare interface FormKitLedger {
    count: (name: string, condition?: FormKitCounterCondition, increment?: number) => Promise<void>;
    init: (node: FormKitNode) => void;
    merge: (child: FormKitNode) => void;
    settled: (name: string) => Promise<void>;
    unmerge: (child: FormKitNode) => void;
    value: (name: string) => number;
}

/**
 * A library of inputs, keyed by the name of the type.
 * @public
 */
export declare interface FormKitLibrary {
    [index: string]: FormKitTypeDefinition;
}

/**
 * The simplest definition for a context of type "list".
 * @public
 */
export declare interface FormKitListContext {
    type: 'list';
    value: FormKitListValue_2;
    _value: FormKitListValue_2;
}

/**
 * A full loop statement in tuple syntax. Can be read like "foreach value, key? in list"
 * @public
 */
export declare type FormKitListStatement = [value: any, key: number | string, list: FormKitListValue] | [value: any, list: FormKitListValue];

/**
 * The value being listed out. Can be an array, an object, or a number.
 * @public
 */
export declare type FormKitListValue = string | Record<string, any> | Array<string | number | Record<string, any>> | number;

/**
 * FormKit inputs of type 'list' must have array values by default.
 * @public
 */
declare type FormKitListValue_2<T = any> = Array<T>;

/**
 * A FormKit message is immutable, so all properties should be readonly.
 * @public
 */
export declare type FormKitMessage = Readonly<FormKitMessageProps>;

/**
 * Messages have can have any arbitrary meta data attached to them.
 * @public
 */
export declare interface FormKitMessageMeta {
    [index: string]: any;
    /**
     * If this property is set, then message producers (like formkit/i18n) should
     * use this key instead of the message key as the lookup for the proper
     * message to produce.
     */
    messageKey?: string;
    /**
     * If this property is set on a message then only the values in this property
     * will be passed as arguments to an i18n message localization function.
     */
    i18nArgs?: any[];
}

/**
 * The structure of an core FormKitMessage. These messages are used to store
 * information about the state of a node.
 * @public
 */
export declare interface FormKitMessageProps {
    blocking: boolean;
    key: string;
    meta: FormKitMessageMeta;
    type: string;
    value?: string | number | boolean;
    visible: boolean;
}

/**
 * Defines the actual store of messages (private).
 * @public
 */
export declare interface FormKitMessageStore {
    [index: string]: FormKitMessage;
}

/**
 * All FormKitMiddleware conform to the pattern of accepting a payload and a
 * `next()` function. They can either pass the payload to the next middleware
 * explicitly (as an argument of next), or implicitly (no argument for next).
 * @public
 */
export declare type FormKitMiddleware<T = unknown> = (payload: T, next: (payload?: T) => T) => T;

/**
 * FormKit's Node object produced by createNode(). All inputs, forms, and groups
 * are instances of nodes.
 * @public
 */
export declare type FormKitNode = {
    /**
     * Boolean true indicating this object is a valid FormKitNode
     */
    readonly __FKNode__: true;
    /**
     * The value of the input. This should never be directly modified. Any
     * desired mutations should be made through node.input()
     */
    readonly value: unknown;
    /**
     * The internal FormKitContext object — this is not a public API and should
     * never be used outside of the core package itself. It is only here for
     * internal use and as an escape hatch.
     */
    _c: FormKitContext;
    /**
     * Add a child to a node, the node must be a group or list.
     */
    add: (node: FormKitNode, index?: number) => FormKitNode;
    /**
     * Adds props to the given node by removing them from node.props.attrs and
     * moving them to the top-level node.props object.
     */
    addProps: (props: string[]) => FormKitNode;
    /**
     * Gets a node at another address. Addresses are dot-syntax paths (or arrays)
     * of node names. For example: form.users.0.first_name There are a few
     * "special" traversal tokens as well:
     * $root - Selects the root node
     * $parent - Selects the parent node
     * $self — Selects the current node
     */
    at: (address: FormKitAddress | string) => FormKitNode | undefined;
    /**
     * The address of the current node, from the root of the tree.
     */
    address: FormKitAddress;
    /**
     * An internal function used to bubble an event from a child to a parent.
     */
    bubble: (event: FormKitEvent) => FormKitNode;
    /**
     * An internal mechanism for calming a disturbance — which is a mechanism
     * used to know the state of input settlement in the tree.
     */
    calm: (childValue?: FormKitChildValue) => FormKitNode;
    /**
     * Clears the errors of the node, and optionally all the children.
     */
    clearErrors: (clearChildren?: boolean, sourceKey?: string) => FormKitNode;
    /**
     * An object that is shared tree-wide with various configuration options that
     * should be applied to the entire tree.
     */
    config: FormKitConfig;
    /**
     * Defines the current input's library type definition including node type,
     * schema, and props.
     */
    define: (definition: FormKitTypeDefinition) => void;
    /**
     * Increments a disturbance. A disturbance is a record that the input or a
     * member of its subtree is no longer "settled". Disturbed nodes are ones
     * that have had their value modified, but have not yet committed that value
     * to the rest of the tree.
     */
    disturb: () => FormKitNode;
    /**
     * Removes the node from the global registry, removes it from its parent, and
     * emits the 'destroying' event.
     */
    destroy: () => void;
    /**
     * Perform given callback on each of the given node's children.
     */
    each: (callback: FormKitChildCallback) => void;
    /**
     * Emit an event from the node.
     */
    emit: (event: string, payload?: any, bubble?: boolean) => FormKitNode;
    /**
     * Within a given tree, find a node matching a given selector. Selectors
     * can be simple strings or a function.
     */
    find: (selector: string, searcher?: keyof FormKitNode | FormKitSearchFunction) => FormKitNode | undefined;
    /**
     * An internal mechanism to hydrate values down a node tree.
     */
    hydrate: () => FormKitNode;
    /**
     * The index of a node compared to its siblings. This is only applicable in
     * cases where a node is a child of a list.
     */
    index: number;
    /**
     * The function used to set the value of a node. All changes to a node's value
     * should use this function as it ensures the tree's state is always fully
     * tracked.
     */
    input: (value: unknown, async?: boolean) => Promise<unknown>;
    /**
     * The name of the input in the node tree. When a node is a child of a list
     * this automatically becomes its index.
     */
    name: string;
    /**
     * Adds an event listener for a given event, and returns a "receipt" which is
     * a random string token. This token should be used to remove the listener
     * in the future. Alternatively you can assign a "receipt" property to the
     * listener function and that receipt will be used instead — this allows
     * multiple listeners to all be de-registered with a single off() call if they
     * share the same receipt.
     */
    on: (eventName: string, listener: FormKitEventListener) => string;
    /**
     * Removes an event listener by its token. Receipts can be shared among many
     * event listeners by explicitly declaring the "receipt" property of the
     * listener function.
     */
    off: (receipt: string) => FormKitNode;
    /**
     * Remove a child from a node.
     */
    remove: (node: FormKitNode) => FormKitNode;
    /**
     * Retrieves the root node of a tree. This is accomplished via tree-traversal
     * on-request, and as such should not be used in frequently called functions.
     */
    root: FormKitNode;
    /**
     * Sets the configuration of a node.
     */
    resetConfig: () => void;
    /**
     * Reset a node’s value back to its original value.
     */
    reset: () => FormKitNode;
    /**
     * Sets errors on the input, and optionally, and child inputs.
     */
    setErrors: (localErrors: ErrorMessages, childErrors?: ErrorMessages) => void;
    /**
     * A promise that resolves when a node and its entire subtree is settled.
     * In other words — all the inputs are done committing their values.
     */
    settled: Promise<unknown>;
    /**
     * Triggers a submit event on the nearest form.
     */
    submit: () => void;
    /**
     * A text or translation function that exposes a given string to the "text"
     * hook — all text shown to users should be passed through this function
     * before being displayed — especially for core and plugin authors.
     */
    t: (key: string | FormKitTextFragment) => string;
    /**
     * Boolean reflecting the settlement state of the node and its subtree.
     */
    isSettled: boolean;
    /**
     * Registers a new plugin on the node and its subtree.
     * run = should the plugin be executed or not
     * library = should the plugin's library function be executed (if there)
     */
    use: (plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>, run?: boolean, library?: boolean) => FormKitNode;
    /**
     * Performs a function on the node and every node in the subtree. This is an
     * expensive operation so it should be done very rarely and only lifecycle
     * events that are relatively rare like boot up and shut down.
     */
    walk: (callback: FormKitChildCallback, stopOnFalse?: boolean) => void;
} & Omit<FormKitContext, 'value' | 'name' | 'config'>;

/**
 * These are the type of nodes that can be created — these are different from
 * the type of inputs available and rather describe their purpose in the tree.
 * @public
 */
export declare type FormKitNodeType = 'input' | 'list' | 'group';

/**
 * Options that can be used to instantiate a new node via createNode()
 * @public
 */
export declare type FormKitOptions = Partial<Omit<FormKitContext, 'children' | 'plugins' | 'config' | 'hook'> & {
    config: Partial<FormKitConfig>;
    props: Partial<FormKitProps>;
    children: FormKitNode[] | Set<FormKitNode>;
    index?: number;
    plugins: FormKitPlugin[];
    alias: string;
    schemaAlias: string;
}>;

/**
 * The base interface definition for a FormKitPlugin — it's just a function that
 * accepts a node argument.
 * @public
 */
export declare interface FormKitPlugin {
    (node: FormKitNode): false | any | void;
    library?: (node: FormKitNode) => void;
}

/**
 * The user-land per-instance "props", which are generally akin to the props
 * passed into components on the front end.
 * @public
 */
export declare type FormKitProps = {
    delay: number;
    id: string;
    validationLabelStrategy?: (node?: FormKitNode) => string;
    validationRules?: Record<string, (node: FormKitNode) => boolean | Promise<boolean>>;
    validationMessages?: Record<string, ((ctx: {
        name: string;
        args: any[];
        node: FormKitNode;
    }) => string) | string>;
    definition?: FormKitTypeDefinition;
    [index: string]: any;
} & FormKitConfig;

/**
 * Global configuration options.
 * @internal
 */
declare type FormKitRootConfig = Partial<FormKitConfig> & {
    _add: (node: FormKitNode) => void;
    _rm: (node: FormKitNode) => void;
};

/**
 * DOM attributes are simple string dictionaries.
 * @public
 */
export declare type FormKitSchemaAttributes = {
    [index: string]: FormKitAttributeValue;
} | null | FormKitSchemaAttributesCondition;

/**
 * Conditions nested inside attribute declarations
 * @public
 */
export declare interface FormKitSchemaAttributesCondition {
    if: string;
    then: FormKitAttributeValue;
    else?: FormKitAttributeValue;
}

/**
 * Properties available when defining a generic non-formkit component.
 * @public
 */
export declare type FormKitSchemaComponent = {
    $cmp: string;
    props?: Record<string, any>;
} & FormKitSchemaProps;

/**
 * Definition for a function that can extend a given schema node.
 * @public
 */
export declare interface FormKitSchemaComposable {
    (extendWith?: Partial<FormKitSchemaNode>, children?: string | FormKitSchemaNode[] | FormKitSchemaCondition, ...args: any[]): FormKitSchemaNode;
}

/**
 * A schema node that determines _which_ content to render.
 * @public
 */
export declare type FormKitSchemaCondition = {
    if: string;
    then: FormKitSchemaNode | FormKitSchemaNode[];
    else?: FormKitSchemaNode | FormKitSchemaNode[];
};

/**
 * The context that is passed from one schema render to the next.
 * @public
 */
export declare interface FormKitSchemaContext {
    [index: string]: any;
    __FK_SCP: Map<symbol, Record<string, any>>;
}

/**
 * Properties available when using a DOM node.
 * @public
 */
export declare type FormKitSchemaDOMNode = {
    $el: string | null;
    attrs?: FormKitSchemaAttributes;
} & FormKitSchemaProps;

/**
 * Syntactic sugar for a FormKitSchemaComponent node that uses formkit.
 * @public
 */
export declare type FormKitSchemaFormKit = {
    $formkit: string;
} & Record<string, any> & FormKitSchemaProps;

/**
 * Meta attributes are not used when parsing the schema, but can be used to
 * create tooling.
 */
declare type FormKitSchemaMeta = {
    [key: string]: string | number | boolean | undefined | null | CallableFunction | FormKitSchemaMeta;
};

/**
 * Properties available then defining a schema node.
 * @public
 */
export declare type FormKitSchemaNode = FormKitSchemaDOMNode | FormKitSchemaComponent | FormKitSchemaTextNode | FormKitSchemaCondition | FormKitSchemaFormKit;

/**
 * Properties available in all schema nodes.
 * @public
 */
export declare interface FormKitSchemaProps {
    children?: string | FormKitSchemaNode[] | FormKitSchemaCondition;
    key?: string;
    if?: string;
    for?: FormKitListStatement;
    bind?: string;
    meta?: FormKitSchemaMeta;
}

/**
 * A simple text node.
 * @public
 */
export declare type FormKitSchemaTextNode = string;

/**
 * Breadth and Depth first searches can use a callback of this notation.
 * @public
 */
export declare type FormKitSearchFunction = (node: FormKitNode, searchTerm?: string | number) => boolean;

/**
 * The message store contains all of the messages that pertain to a given node.
 * @public
 */
export declare type FormKitStore = FormKitMessageStore & {
    _n: FormKitNode;
    _b: Array<[messages: FormKitMessage[], clear?: MessageClearer]>;
    _m: ChildMessageBuffer;
    _r?: string;
    buffer: boolean;
} & FormKitStoreTraps;

/**
 * The available traps on the FormKit store.
 */
declare interface FormKitStoreTraps {
    apply: (messages: Array<FormKitMessage> | FormKitInputMessages, clear?: MessageClearer) => void;
    set: (message: FormKitMessageProps) => FormKitStore;
    remove: (key: string) => FormKitStore;
    filter: (callback: (message: FormKitMessage) => boolean, type?: string) => FormKitStore;
    reduce: <T>(reducer: (accumulator: T, message: FormKitMessage) => T, accumulator: T) => T;
    release: () => void;
    touch: () => void;
}

/**
 * Text fragments are small pieces of text used for things like interface
 * validation messages, or errors that may be exposed for modification or
 * even translation.
 * @public
 */
export declare type FormKitTextFragment = Partial<FormKitMessageProps> & {
    key: string;
    value: string;
    type: string;
};

/**
 * The definition of a FormKitTrap — these are somewhat like methods on each
 * FormKitNode — they are always symmetrical (get/set), although it's acceptable
 * for either to throw an Exception.
 * @public
 */
export declare interface FormKitTrap {
    get: TrapGetter;
    set: TrapSetter;
}

/**
 * The map signature for a node's traps Map.
 * @public
 */
export declare type FormKitTraps = Map<string | symbol, FormKitTrap>;

/**
 * Definition of a library item — when registering a new library item, these
 * are the required and available properties.
 * @public
 */
export declare type FormKitTypeDefinition = {
    /**
     * The FormKit core node type. Can only be input | list | group.
     */
    type: FormKitNodeType;
    /**
     * Groups the input into a given family of inputs, generally for styling
     * purposes only. For example the "text" family would apply to all text-like
     * inputs.
     */
    family?: string;
    /**
     * An optional name for the input’s type (e.g. "select" for a select input).
     * If used, this value takes precedence over the "type" prop string.
     */
    forceTypeProp?: string;
    /**
     * Custom props that should be added to the input.
     */
    props?: string[];
    /**
     * The schema used to create the input. Either this or the component is
     * required.
     */
    schema?: FormKitExtendableSchemaRoot | FormKitSchemaNode[] | FormKitSchemaCondition;
    /**
     * A component to use to render the input. Either this or the schema is
     * required.
     */
    component?: unknown;
    /**
     * A library of components to provide to the internal input schema.
     */
    library?: Record<string, unknown>;
    /**
     * An array of additional feature functions to load when booting the input.
     */
    features?: Array<(node: FormKitNode) => void>;
};

/**
 * Combines multiple class lists into a single list
 * @param node - the FormKit node being operated on
 * @param property - The property key to which the class list will be applied
 * @param args - CSS class list(s)
 * @returns
 * @public
 */
export declare function generateClassList(node: FormKitNode, property: string, ...args: Record<string, boolean>[]): string | null;

/**
 * Get a node by a particular id.
 * @param node - Get a node by a given id
 * @public
 */
export declare function getNode(id: string): FormKitNode | undefined;

/**
 * Type narrow that a node is a DOM node.
 * @param node - A schema node to check
 * @returns
 * @public
 */
export declare function isComponent(node: string | Record<PropertyKey, any>): node is FormKitSchemaComponent;

/**
 * Determines if a node is conditionally rendered or not.
 * @param node - A schema node to check
 * @returns
 * @public
 */
export declare function isConditional(node: FormKitSchemaNode): node is FormKitSchemaCondition;

/**
 * Determines if an attribute is a conditional.
 * @param node - A schema node to check
 * @returns
 * @public
 */
export declare function isConditional(node: FormKitSchemaAttributesCondition | FormKitSchemaAttributes): node is FormKitSchemaAttributesCondition;

/**
 * Type narrow that a node is a DOM node.
 * @param node - A schema node to check
 * @returns
 * @public
 */
export declare function isDOM(node: string | Record<PropertyKey, any>): node is FormKitSchemaDOMNode;

/**
 * A simple type guard to determine if the context being evaluated is a list
 * type.
 * @param arg -
 * @returns arg is FormKitListContext
 * @public
 */
export declare function isList(arg: FormKitContextShape): arg is FormKitListContext;

/**
 * Determine if a given object is a node
 * @public
 */
export declare function isNode(node: any): node is FormKitNode;

/**
 * Determines if the node is syntactic sugar or not.
 * @param node - Node
 * @returns
 * @public
 */
export declare function isSugar(node: FormKitSchemaNode): node is FormKitSchemaFormKit;

/**
 * Arbitrary data that has properties, could be a pojo, could be an array.
 * @public
 */
export declare interface KeyedValue {
    [index: number]: any;
    [index: string]: any;
}

/**
 * A string or function that allows clearing messages.
 */
declare type MessageClearer = string | ((message: FormKitMessage) => boolean);

/**
 * Create a name based dictionary of all children in an array.
 * @param children -
 * @public
 */
export declare function names(children: FormKitNode[]): {
    [index: string]: FormKitNode;
};

/**
 * Registers a node to the registry _if_ the node is a root node, _or_ if the
 * node has an explicit node.props.alias. If these two things are not true
 * then no node is registered (idempotent).
 *
 * @param node - A node to register
 * @public
 */
export declare function register(node: FormKitNode): void;

/**
 * Resets an input to it’s "initial" value — if the input is a group or list it
 * resets all the children as well.
 * @param id - The id of an input to reset
 * @returns
 * @public
 */
export declare function reset(id: string | FormKitNode, resetTo?: unknown): FormKitNode | undefined;

/**
 * Reports the global number of node registrations, useful for deterministic
 * node naming.
 * @public
 */
export declare function resetCount(): void;

/**
 * Reset the entire registry.
 * @public
 */
export declare function resetRegistry(): void;

/**
 * Sets errors on a form, group, or input.
 * @param formId - The id of a form
 * @param localErrors - The errors to set on the form or the form’s inputs
 * @param childErrors - (optional) The errors to set on the form or the form’s inputs
 * @public
 */
export declare function setErrors(id: string, localErrors: ErrorMessages, childErrors?: ErrorMessages): void;

/**
 * Submits a FormKit form programmatically.
 * @param id - The id of the form
 * @public
 */
export declare function submitForm(id: string): void;

/**
 * Converts syntactic sugar nodes to standard nodes.
 * @param node - A node to covert
 * @returns
 * @public
 */
export declare function sugar<T extends FormKitSchemaNode>(node: T): Exclude<FormKitSchemaNode, string | FormKitSchemaFormKit>;

/**
 * Signature for any of the node's getter traps. Keep in mind that because these
 * are traps and not class methods, their response types are declared explicitly
 * in the FormKitNode interface.
 * @public
 */
export declare type TrapGetter = ((node: FormKitNode, context: FormKitContext, ...args: any[]) => unknown) | false;

/**
 * The signature for a node's trap setter — these are more rare than getter
 * traps, but can be really useful for blocking access to certain context
 * properties or modifying the behavior of an assignment (ex. see setParent)
 * @public
 */
export declare type TrapSetter = ((node: FormKitNode, context: FormKitContext, property: string | number | symbol, value: any) => boolean | never) | false;

/**
 * Adds a plugin to the node, it’s children, and executes it.
 * @param context -
 * @param node -
 * @param plugin -
 * @public
 */
export declare function use(node: FormKitNode, context: FormKitContext, plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>, run?: boolean, library?: boolean): FormKitNode;

/**
 * If a node’s name is set to useIndex, it replaces the node’s name with the
 * index of the node relative to its parent’s children.
 * @public
 */
export declare const useIndex: unique symbol;

/**
 * When creating a new node and having its value injected directly at a specific
 * location.
 * @public
 */
export declare const valueInserted: unique symbol;

/**
 * When propagating values up a tree, this value indicates the child should be
 * moved.
 * @public
 */
export declare const valueMoved: unique symbol;

/**
 * When propagating values up a tree, this value indicates the child should be
 * removed.
 * @public
 */
export declare const valueRemoved: unique symbol;

/**
 * Globally emits a warning.
 * @param code - The integer error code.
 * @param data - Usually an object of information to include.
 * @public
 */
export declare function warn(code: number, data?: any): void;

/**
 * FormKit's global warning handler.
 * @public
 */
export declare const warningHandler: FormKitDispatcher<FormKitHandlerPayload>;

/**
 *
 * @param id - An id to watch
 * @param callback - A callback to notify when the node is set or removed.
 * @public
 */
export declare function watchRegistry(id: string, callback: FormKitEventListener): void;

export { }
