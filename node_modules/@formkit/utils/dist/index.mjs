/**
 * Explicit keys that should always be cloned.
 */
const explicitKeys = [
    '__key',
    '__init',
    '__shim',
    '__original',
    '__index',
    '__prevKey',
];
/**
 * Generates a random string.
 * @returns string
 * @public
 */
function token() {
    return Math.random().toString(36).substring(2, 15);
}
/**
 * Creates a new set of the specified type and uses the values from an Array or
 * an existing Set.
 * @param items -
 * @returns Set
 * @public
 */
function setify(items) {
    return items instanceof Set ? items : new Set(items);
}
/**
 * Given 2 arrays, return them as a combined array with no duplicates.
 * @param arr1 -
 * @param arr2 -
 * @returns any[]
 * @public
 */
function dedupe(arr1, arr2) {
    const original = arr1 instanceof Set ? arr1 : new Set(arr1);
    if (arr2)
        arr2.forEach((item) => original.add(item));
    return [...original];
}
/**
 * Checks if the given property exists on the given object.
 * @param obj -
 * @param property -
 * @public
 */
function has(obj, property) {
    return Object.prototype.hasOwnProperty.call(obj, property);
}
/**
 * Compare two values for equality optionally at depth.
 * @param valA - Any type of input
 * @param valB - Any type of output
 * @param deep - Indicate if we should recurse into the object
 * @param explicit - Explicit keys
 * @returns boolean
 * @public
 */
function eq(valA, // eslint-disable-line
valB, // eslint-disable-line
deep = true, explicit = ['__key']) {
    if (valA === valB)
        return true;
    if (typeof valB === 'object' && typeof valA === 'object') {
        if (valA instanceof Map)
            return false;
        if (valA instanceof Set)
            return false;
        if (valA instanceof Date)
            return false;
        if (valA === null || valB === null)
            return false;
        if (Object.keys(valA).length !== Object.keys(valB).length)
            return false;
        for (const k of explicit) {
            if ((k in valA || k in valB) && valA[k] !== valB[k])
                return false;
        }
        for (const key in valA) {
            if (!(key in valB))
                return false;
            if (valA[key] !== valB[key] && !deep)
                return false;
            if (deep && !eq(valA[key], valB[key], deep, explicit))
                return false;
        }
        return true;
    }
    return false;
}
/**
 * Determines if a value is empty or not.
 * @param value - any type of value that could be returned by an input.
 * @public
 */
function empty(value // eslint-disable-line
) {
    const type = typeof value;
    if (type === 'number')
        return false;
    if (value === undefined)
        return true;
    if (type === 'string') {
        return value === '';
    }
    if (type === 'object') {
        if (value === null)
            return true;
        for (const _i in value)
            return false;
        if (value instanceof RegExp)
            return false;
        if (value instanceof Date)
            return false;
        return true;
    }
    return false;
}
/**
 * Escape a string for use in regular expressions.
 * @param string - The string to escape.
 * @public
 */
function escapeExp(string) {
    // $& means the whole matched string
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
/**
 * Given a string format (date) return a regex to match against.
 * @param format - The format of the string
 * @returns
 * @public
 */
function regexForFormat(format) {
    const escaped = `^${escapeExp(format)}$`;
    const formats = {
        MM: '(0[1-9]|1[012])',
        M: '([1-9]|1[012])',
        DD: '([012][0-9]|3[01])',
        D: '([012]?[0-9]|3[01])',
        YYYY: '\\d{4}',
        YY: '\\d{2}',
    };
    const tokens = Object.keys(formats);
    return new RegExp(tokens.reduce((regex, format) => {
        return regex.replace(format, formats[format]);
    }, escaped));
}
/**
 * Given a FormKit input type
 * @param type - Any FormKit input type
 * @public
 */
function nodeType(type) {
    const t = type.toLowerCase();
    if (t === 'list')
        return 'list';
    if (t === 'group')
        return 'group';
    return 'input';
}
/**
 * Determines if an object is an object or not.
 * @param o - any value
 * @returns
 * @public
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isRecord(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
}
/**
 * Checks if an object is a simple array or record.
 * @param o - A value to check
 * @returns
 * @public
 */
function isObject(o) {
    return isRecord(o) || Array.isArray(o);
}
/**
 * Attempts to determine if an object is a plain object. Mostly lifted from
 * is-plain-object: https://github.com/jonschlinkert/is-plain-object
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * @param o - any value
 * @returns
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function isPojo(o) {
    if (isRecord(o) === false)
        return false;
    if (o.__FKNode__ || o.__POJO__ === false)
        return false;
    const ctor = o.constructor;
    if (ctor === undefined)
        return true;
    const prot = ctor.prototype;
    if (isRecord(prot) === false)
        return false;
    if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
    }
    return true;
}
/**
 * Recursively merge data from additional into original returning a new object.
 * @param original - An object to extend
 * @param additional - An object to modify the original object with.
 * @param arrays - By default replaces arrays, but can also append to them.
 * @param ignoreUndefined - when true it treats undefined values as if they dont exist
 * @public
 */
function extend(original, additional, extendArrays = false, ignoreUndefined = false) {
    if (additional === null)
        return null;
    const merged = {};
    if (typeof additional === 'string')
        return additional;
    for (const key in original) {
        if (has(additional, key) &&
            (additional[key] !== undefined || !ignoreUndefined)) {
            if (extendArrays &&
                Array.isArray(original[key]) &&
                Array.isArray(additional[key])) {
                merged[key] = original[key].concat(additional[key]);
                continue;
            }
            if (additional[key] === undefined) {
                continue;
            }
            if (isPojo(original[key]) && isPojo(additional[key])) {
                merged[key] = extend(original[key], additional[key], extendArrays, ignoreUndefined);
            }
            else {
                merged[key] = additional[key];
            }
        }
        else {
            merged[key] = original[key];
        }
    }
    for (const key in additional) {
        if (!has(merged, key) && additional[key] !== undefined) {
            merged[key] = additional[key];
        }
    }
    return merged;
}
/**
 * Determine if the given string is fully quoted. Examples:
 * hello - false
 * "hello" - true
 * 'world' - true
 * "hello"=="world" - false
 * "hello'this'" - false
 * "hello"'there' - false
 * "hello""there" - false
 * 'hello === world' - true
 * @param str - A string to check.
 * @public
 */
function isQuotedString(str) {
    // quickly return false if the value is note quoted
    if (str[0] !== '"' && str[0] !== "'")
        return false;
    if (str[0] !== str[str.length - 1])
        return false;
    const quoteType = str[0];
    for (let p = 1; p < str.length; p++) {
        if (str[p] === quoteType &&
            (p === 1 || str[p - 1] !== '\\') &&
            p !== str.length - 1) {
            return false;
        }
    }
    return true;
}
/**
 * Remove extra escape characters.
 * @param str - A string to remove escape characters from.
 * @public
 */
function rmEscapes(str) {
    if (!str.length)
        return '';
    let clean = '';
    let lastChar = '';
    for (let p = 0; p < str.length; p++) {
        const char = str.charAt(p);
        if (char !== '\\' || lastChar === '\\') {
            clean += char;
        }
        lastChar = char;
    }
    return clean;
}
/**
 * Performs a recursive Object.assign like operation.
 * @param a - An object to be extended by object b
 * @param b - An object to copy values from
 * @public
 */
function assignDeep(a, b) {
    for (const key in a) {
        if (has(b, key) &&
            a[key] !== b[key] &&
            !(isPojo(a[key]) && isPojo(b[key]))) {
            a[key] = b[key];
        }
        else if (isPojo(a[key]) && isPojo(b[key])) {
            assignDeep(a[key], b[key]);
        }
    }
    for (const key in b) {
        if (!has(a, key)) {
            a[key] = b[key];
        }
    }
    return a;
}
/**
 * Filters out values from an object that should not be considered "props" of
 * a core node, like "value" and "name".
 * @param attrs - An object to extract core node config from.
 * @public
 */
function nodeProps(...sets) {
    return sets.reduce((valid, props) => {
        const { value, name, modelValue, config, plugins, ...validProps } = props; // eslint-disable-line
        return Object.assign(valid, validProps);
    }, {});
}
/**
 * Parse a string for comma-separated arguments
 * @param str - A string to parse
 * @public
 */
function parseArgs(str) {
    const args = [];
    let arg = '';
    let depth = 0;
    let quote = '';
    let lastChar = '';
    for (let p = 0; p < str.length; p++) {
        const char = str.charAt(p);
        if (char === quote && lastChar !== '\\') {
            quote = '';
        }
        else if ((char === "'" || char === '"') && !quote && lastChar !== '\\') {
            quote = char;
        }
        else if (char === '(' && !quote) {
            depth++;
        }
        else if (char === ')' && !quote) {
            depth--;
        }
        if (char === ',' && !quote && depth === 0) {
            args.push(arg);
            arg = '';
        }
        else if (char !== ' ' || quote) {
            arg += char;
        }
        lastChar = char;
    }
    if (arg) {
        args.push(arg);
    }
    return args;
}
/**
 * Return a new (shallow) object with all properties from a given object
 * that are present in the array.
 * @param obj - An object to clone
 * @param toRemove - An array of keys to remove
 * @public
 */
function except(obj, toRemove) {
    const clean = {};
    const exps = toRemove.filter((n) => n instanceof RegExp);
    const keysToRemove = new Set(toRemove);
    for (const key in obj) {
        if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {
            clean[key] = obj[key];
        }
    }
    return clean;
}
/**
 * Extracts a set of keys from a given object. Importantly, this will extract
 * values even if they are not set on the original object they will just have an
 * undefined value.
 * @param obj - An object to extract values from
 * @param include - A set of keys to extract
 * @returns
 * @public
 */
function only(obj, include) {
    const clean = {};
    const exps = include.filter((n) => n instanceof RegExp);
    include.forEach((key) => {
        if (!(key instanceof RegExp)) {
            clean[key] = obj[key];
        }
    });
    Object.keys(obj).forEach((key) => {
        if (exps.some((exp) => exp.test(key))) {
            clean[key] = obj[key];
        }
    });
    return clean;
}
/**
 * This converts kebab-case to camelCase. It ONLY converts from kebab for
 * efficiency stake.
 * @param str - String to convert.
 * @public
 */
function camel(str) {
    return str.replace(/-([a-z0-9])/gi, (_s, g) => g.toUpperCase());
}
/**
 * This converts camel-case to kebab case. It ONLY converts from camel to kebab.
 * @param str - Converts camel to kebab
 * @returns
 * @public
 */
function kebab(str) {
    return str
        .replace(/([a-z0-9])([A-Z])/g, (_s, trail, cap) => trail + '-' + cap.toLowerCase())
        .replace(' ', '-')
        .toLowerCase();
}
/**
 * Very shallowly clones the given object.
 * @param obj - The object to shallow clone
 * @returns
 * @public
 */
function shallowClone(obj, explicit = explicitKeys) {
    if (obj !== null && typeof obj === 'object') {
        let returnObject;
        if (Array.isArray(obj))
            returnObject = [...obj];
        else if (isPojo(obj))
            returnObject = { ...obj };
        if (returnObject) {
            applyExplicit(obj, returnObject, explicit);
            return returnObject;
        }
    }
    return obj;
}
/**
 * Perform a recursive clone on a given object. This only intended to be used
 * for simple objects like arrays and pojos.
 * @param obj - Object to clone
 * @public
 */
function clone(obj, explicit = explicitKeys) {
    if (obj === null ||
        obj instanceof RegExp ||
        obj instanceof Date ||
        obj instanceof Map ||
        obj instanceof Set ||
        (typeof File === 'function' && obj instanceof File))
        return obj;
    let returnObject;
    if (Array.isArray(obj)) {
        returnObject = obj.map((value) => {
            if (typeof value === 'object')
                return clone(value, explicit);
            return value;
        });
    }
    else {
        returnObject = Object.keys(obj).reduce((newObj, key) => {
            newObj[key] =
                typeof obj[key] === 'object'
                    ? clone(obj[key], explicit)
                    : obj[key];
            return newObj;
        }, {});
    }
    for (const key of explicit) {
        if (key in obj) {
            Object.defineProperty(returnObject, key, {
                enumerable: false,
                value: obj[key],
            });
        }
    }
    return returnObject;
}
/**
 * Clones anything. If the item is scalar, no worries, it passes it back. if it
 * is an object, it performs a (fast/loose) clone operation.
 * @param obj - The object to clone
 * @public
 */
function cloneAny(obj) {
    return typeof obj === 'object'
        ? clone(obj)
        : obj;
}
/**
 * Get a specific value via dot notation.
 * @param obj - An object to fetch data from
 * @param addr - An "address" in dot notation
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function getAt(obj, addr) {
    if (!obj || typeof obj !== 'object')
        return null;
    const segments = addr.split('.');
    let o = obj;
    for (const i in segments) {
        const segment = segments[i];
        if (has(o, segment)) {
            o = o[segment];
        }
        if (+i === segments.length - 1)
            return o;
        if (!o || typeof o !== 'object')
            return null;
    }
    return null;
}
/**
 * Determines if the value of a prop that is either present (true) or not
 * present (undefined). For example the prop disabled should disable
 * by just existing, but what if it is set to the string "false" â€” then it
 * should not be disabled.
 * @param value - value to be checked
 * @returns
 * @public
 */
function undefine(value) {
    return value !== undefined && value !== 'false' && value !== false
        ? true
        : undefined;
}
/**
 * Defines an object as an initial value.
 * @param obj - Object
 * @returns
 * @public
 */
/* eslint-disable-next-line @typescript-eslint/ban-types */
function init(obj) {
    return !Object.isFrozen(obj)
        ? Object.defineProperty(obj, '__init', {
            enumerable: false,
            value: true,
        })
        : obj;
}
/**
 * Turn any string into a URL/DOM safe string.
 * @public
 */
function slugify(str) {
    return str
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]/g, ' ')
        .trim()
        .replace(/\s+/g, '-');
}
/**
 * Spreads an object or an array, otherwise returns the same value.
 * @param obj - Any value, but will spread objects and arrays
 * @public
 */
function spread(obj, explicit = explicitKeys) {
    if (obj && typeof obj === 'object') {
        if (obj instanceof RegExp)
            return obj;
        if (obj instanceof Date)
            return obj;
        let spread;
        if (Array.isArray(obj)) {
            spread = [...obj];
        }
        else {
            spread = { ...obj };
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        return applyExplicit(obj, spread, explicit);
    }
    return obj;
}
/**
 * Apply non enumerable properties to an object.
 * @param obj - The object to apply non-enumerable properties to
 * @param explicit - An array of non-enumerable properties to apply
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function applyExplicit(original, obj, explicit) {
    for (const key of explicit) {
        if (key in original) {
            Object.defineProperty(obj, key, {
                enumerable: false,
                value: original[key],
            });
        }
    }
    return obj;
}

export { assignDeep, camel, clone, cloneAny, dedupe, empty, eq, escapeExp, except, extend, getAt, has, init, isObject, isPojo, isQuotedString, isRecord, kebab, nodeProps, nodeType, only, parseArgs, regexForFormat, rmEscapes, setify, shallowClone, slugify, spread, token, undefine };
