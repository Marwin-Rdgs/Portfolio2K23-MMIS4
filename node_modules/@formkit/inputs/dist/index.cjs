'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@formkit/utils');
var core = require('@formkit/core');

/**
 *
 * @param libraries - One or many formkit urls.
 * @returns
 * @public
 */
function createLibraryPlugin(...libraries) {
    /**
     * Merge all provided library items.
     */
    const library = libraries.reduce((merged, lib) => utils.extend(merged, lib), {});
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    const plugin = () => { };
    /**
     * Enables the hook that exposes all library inputs.
     * @param node - The primary plugin
     */
    plugin.library = function (node) {
        const type = utils.camel(node.props.type);
        if (utils.has(library, type)) {
            node.define(library[type]);
        }
    };
    return plugin;
}

/**
 * Accepts an array of objects, array of strings, or object of key-value pairs.
 * and returns an array of objects with value and label properties.
 * @param options - Options to normalize
 * @public
 */
function normalizeOptions(options) {
    let i = 1;
    if (Array.isArray(options)) {
        return options.map((option) => {
            if (typeof option === 'string' || typeof option === 'number') {
                return {
                    label: String(option),
                    value: String(option),
                };
            }
            if (typeof option == 'object') {
                if ('value' in option && typeof option.value !== 'string') {
                    Object.assign(option, {
                        value: `__mask_${i++}`,
                        __original: option.value,
                    });
                }
            }
            return option;
        });
    }
    return Object.keys(options).map((value) => {
        return {
            label: options[value],
            value,
        };
    });
}
/**
 * Given an option list, find the "true" value in the options.
 * @param options - The options to check for a given value
 * @param value - The value to return
 * @returns
 */
function optionValue(options, value) {
    if (Array.isArray(options)) {
        for (const option of options) {
            if (value == option.value) {
                return '__original' in option ? option.__original : option.value;
            }
        }
    }
    return value;
}
/**
 * Determines if the value should be selected.
 * @param valueA - Any type of value
 * @param valueB - Any type of value
 */
function shouldSelect(valueA, valueB) {
    if (valueA == valueB)
        return true;
    if (utils.isPojo(valueA) && utils.isPojo(valueB))
        return utils.eq(valueA, valueB);
    return false;
}
/**
 * Converts the options prop to usable values.
 * @param node - A formkit node.
 * @public
 */
function options(node) {
    node.hook.prop((prop, next) => {
        if (prop.prop === 'options') {
            if (typeof prop.value === 'function') {
                node.props.optionsLoader = prop.value;
                prop.value = [];
            }
            else {
                prop.value = normalizeOptions(prop.value);
            }
        }
        return next(prop);
    });
}

/**
 * @public
 */
const outer = createSection('outer', () => ({
    $el: 'div',
    attrs: {
        key: '$id',
        'data-family': '$family || undefined',
        'data-type': '$type',
        'data-multiple': '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
        'data-disabled': '$disabled || undefined',
        'data-complete': '$state.complete || undefined',
        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',
        'data-errors': '$state.errors || undefined',
        'data-submitted': '$state.submitted || undefined',
        'data-prefix-icon': '$_rawPrefixIcon !== undefined || undefined',
        'data-suffix-icon': '$_rawSuffixIcon !== undefined || undefined',
        'data-prefix-icon-click': '$onPrefixIconClick !== undefined || undefined',
        'data-suffix-icon-click': '$onSuffixIconClick !== undefined || undefined',
    },
}), true);

/**
 * @public
 */
const inner = createSection('inner', 'div');

/**
 * @public
 */
const wrapper = createSection('wrapper', 'div');

/**
 * @public
 */
const label = createSection('label', () => ({
    $el: 'label',
    if: '$label',
    attrs: {
        for: '$id',
    },
}));

/**
 * @public
 */
const messages = createSection('messages', () => ({
    $el: 'ul',
    if: '$fns.length($messages)',
}));

/**
 * @public
 */
const message = createSection('message', () => ({
    $el: 'li',
    for: ['message', '$messages'],
    attrs: {
        key: '$message.key',
        id: `$id + '-' + $message.key`,
        'data-message-type': '$message.type',
    },
}));

/**
 * @public
 */
const prefix = createSection('prefix', null);

/**
 * @public
 */
const suffix = createSection('suffix', null);

/**
 * @public
 */
const help = createSection('help', () => ({
    $el: 'div',
    if: '$help',
    attrs: {
        id: '$: "help-" + $id',
    },
}));

/**
 * @public
 */
const fieldset = createSection('fieldset', () => ({
    $el: 'fieldset',
    attrs: {
        id: '$id',
        'aria-describedby': {
            if: '$help',
            then: '$: "help-" + $id',
            else: undefined,
        },
    },
}));

/**
 * @public
 */
const decorator = createSection('decorator', () => ({
    $el: 'span',
    attrs: {
        'aria-hidden': 'true',
    },
}));

/**
 * @public
 */
const box = createSection('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: '$type',
        name: '$node.props.altName || $node.name',
        disabled: '$option.attrs.disabled || $disabled',
        onInput: '$handlers.toggleChecked',
        checked: '$fns.eq($_value, $onValue)',
        onBlur: '$handlers.blur',
        value: '$: true',
        id: '$id',
        'aria-describedby': {
            if: '$options.length',
            then: {
                if: '$option.help',
                then: '$: "help-" + $option.attrs.id',
                else: undefined,
            },
            else: {
                if: '$help',
                then: '$: "help-" + $id',
                else: undefined,
            },
        },
    },
}));

/**
 * @public
 */
const legend = createSection('legend', () => ({
    $el: 'legend',
    if: '$label',
}));

/**
 * @public
 */
const boxOption = createSection('option', () => ({
    $el: 'li',
    for: ['option', '$options'],
    attrs: {
        'data-disabled': '$option.attrs.disabled || $disabled',
    },
}));

/**
 * @public
 */
const boxOptions = createSection('options', 'ul');

/**
 * @public
 */
const boxWrapper = createSection('wrapper', () => ({
    $el: 'label',
    attrs: {
        'data-disabled': {
            if: '$options.length',
            then: undefined,
            else: '$disabled || undefined',
        },
    },
}));

/**
 * @public
 */
const boxHelp = createSection('optionHelp', () => ({
    $el: 'div',
    if: '$option.help',
    attrs: {
        id: '$: "help-" + $option.attrs.id',
    },
}));

/**
 * @public
 */
const boxLabel = createSection('label', 'span');

/**
 * @public
 */
const buttonInput = createSection('input', () => ({
    $el: 'button',
    bind: '$attrs',
    attrs: {
        type: '$type',
        disabled: '$disabled',
        name: '$node.name',
        id: '$id',
    },
}));

/**
 * @public
 */
const buttonLabel = createSection('default', null);

/**
 * @public
 */
const fileInput = createSection('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: 'file',
        disabled: '$disabled',
        name: '$node.name',
        onChange: '$handlers.files',
        onBlur: '$handlers.blur',
        id: '$id',
        'aria-describedby': '$describedBy',
    },
}));

/**
 * @public
 */
const fileItem = createSection('fileItem', () => ({
    $el: 'li',
    for: ['file', '$value'],
}));

/**
 * @public
 */
const fileList = createSection('fileList', () => ({
    $el: 'ul',
    if: '$value.length',
    attrs: {
        'data-has-multiple': {
            if: '$value.length > 1',
            then: 'true',
        },
    },
}));

/**
 * @public
 */
const fileName = createSection('fileName', () => ({
    $el: 'span',
    attrs: {
        class: '$classes.fileName',
    },
}));

/**
 * @public
 */
const fileRemove = createSection('fileRemove', () => ({
    $el: 'button',
    attrs: {
        onClick: '$handlers.resetFiles',
    },
}));

/**
 * @public
 */
const noFiles = createSection('noFiles', () => ({
    $el: 'span',
    if: '$value.length == 0',
}));

/**
 * @public
 */
const formInput = createSection('form', () => ({
    $el: 'form',
    bind: '$attrs',
    attrs: {
        id: '$id',
        name: '$node.name',
        onSubmit: '$handlers.submit',
        'data-loading': '$state.loading || undefined',
    },
}), true);

/**
 * @public
 */
const actions = createSection('actions', () => ({
    $el: 'div',
    if: '$actions',
}));

/**
 * @public
 */
const submitInput = createSection('submit', () => ({
    $cmp: 'FormKit',
    bind: '$submitAttrs',
    props: {
        ignore: true,
        type: 'submit',
        disabled: '$disabled',
        label: '$submitLabel',
    },
}));

/**
 * @public
 */
const textInput = createSection('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: '$type',
        disabled: '$disabled',
        name: '$node.name',
        onInput: '$handlers.DOMInput',
        onBlur: '$handlers.blur',
        value: '$_value',
        id: '$id',
        'aria-describedby': '$describedBy',
    },
}));

/**
 * @public
 */
const fragment = createSection('wrapper', null, true);

/**
 * @public
 */
const selectInput$1 = createSection('input', () => ({
    $el: 'select',
    bind: '$attrs',
    attrs: {
        id: '$id',
        'data-placeholder': '$fns.showPlaceholder($_value, $placeholder)',
        disabled: '$disabled',
        class: '$classes.input',
        name: '$node.name',
        onChange: '$handlers.onChange',
        onInput: '$handlers.selectInput',
        onBlur: '$handlers.blur',
        'aria-describedby': '$describedBy',
    },
}));

/**
 * @public
 */
const option = createSection('option', () => ({
    $el: 'option',
    for: ['option', '$options'],
    bind: '$option.attrs',
    attrs: {
        class: '$classes.option',
        value: '$option.value',
        selected: '$fns.isSelected($option)',
    },
}));

/**
 * @public
 */
const optionSlot = () => ({
    $el: null,
    if: '$options.length',
    for: ['option', '$options'],
    children: '$slots.option',
});

/**
 * @public
 */
const textareaInput = createSection('input', () => ({
    $el: 'textarea',
    bind: '$attrs',
    attrs: {
        disabled: '$disabled',
        name: '$node.name',
        onInput: '$handlers.DOMInput',
        onBlur: '$handlers.blur',
        value: '$_value',
        id: '$id',
        'aria-describedby': '$describedBy',
    },
    children: '$initialValue',
}));

/**
 * @public
 */
const icon = (sectionKey, el) => {
    return createSection(`${sectionKey}Icon`, () => {
        const rawIconProp = `_raw${sectionKey
            .charAt(0)
            .toUpperCase()}${sectionKey.slice(1)}Icon`;
        return {
            if: `$${sectionKey}Icon && $${rawIconProp}`,
            $el: `${el ? el : 'span'}`,
            attrs: {
                class: `$classes.${sectionKey}Icon + " formkit-icon"`,
                innerHTML: `$${rawIconProp}`,
                onClick: `$handlers.iconClick(${sectionKey})`,
                for: {
                    if: `${el === 'label'}`,
                    then: '$id',
                },
            },
        };
    })();
};

/**
 * Normalize the boxes.
 * @param node - The node
 * @returns
 * @public
 */
function normalizeBoxes(node) {
    return function (prop, next) {
        if (prop.prop === 'options' && Array.isArray(prop.value)) {
            prop.value = prop.value.map((option) => {
                var _a;
                if (!((_a = option.attrs) === null || _a === void 0 ? void 0 : _a.id)) {
                    return utils.extend(option, {
                        attrs: { id: `${node.name}-option-${utils.kebab(String(option.value))}` },
                    });
                }
                return option;
            });
            if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {
                if (node.isCreated) {
                    node.input([], false);
                }
                else {
                    node.on('created', () => {
                        if (!Array.isArray(node.value)) {
                            node.input([], false);
                        }
                    });
                }
            }
        }
        return next(prop);
    };
}

/**
 * Event handler when an input is toggled.
 * @param node - The node being toggled
 * @param e - The input even related to the toggling
 * @public
 */
function toggleChecked$1(node, e) {
    const el = e.target;
    if (el instanceof HTMLInputElement) {
        const value = Array.isArray(node.props.options)
            ? optionValue(node.props.options, el.value)
            : el.value;
        if (Array.isArray(node.props.options) && node.props.options.length) {
            if (!Array.isArray(node._value)) {
                // There is no array value set
                node.input([value]);
            }
            else if (!node._value.some((existingValue) => shouldSelect(value, existingValue))) {
                // The value is not in the current set
                node.input([...node._value, value]);
            }
            else {
                // Filter out equivalent values
                node.input(node._value.filter((existingValue) => !shouldSelect(value, existingValue)));
            }
        }
        else {
            if (el.checked) {
                node.input(node.props.onValue);
            }
            else {
                node.input(node.props.offValue);
            }
        }
    }
}
/**
 * Checks if a given option is present in the node value.
 * @param node - The node being checked
 * @param value - The value of any option
 * @returns
 */
function isChecked$1(node, value) {
    var _a, _b;
    // We need to force vue’s reactivity to respond when the value is run:
    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
    if (Array.isArray(node._value)) {
        return node._value.some((existingValue) => shouldSelect(optionValue(node.props.options, value), existingValue));
    }
    return false;
}
/**
 * Adds checkbox selection support
 * @param node - Node the feature is added to
 * @public
 */
function checkboxes(node) {
    node.on('created', () => {
        var _a, _b;
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
            node.context.fns.isChecked = isChecked$1.bind(null, node);
        }
        // Configure our default onValue and offValue
        if (!utils.has(node.props, 'onValue'))
            node.props.onValue = true;
        if (!utils.has(node.props, 'offValue'))
            node.props.offValue = false;
    });
    node.hook.prop(normalizeBoxes(node));
}

/**
 * Allows disabling children of this.
 * @param node - The FormKitNode of the form/group/list
 * @public
 */
function disables(node) {
    node.on('created', () => {
        node.props.disabled = utils.undefine(node.props.disabled);
    });
    node.hook.prop(({ prop, value }, next) => {
        value = prop === 'disabled' ? utils.undefine(value) : value;
        return next({ prop, value });
    });
    node.on('prop:disabled', ({ payload: value }) => {
        node.config.disabled = utils.undefine(value);
    });
    node.on('created', () => {
        node.config.disabled = utils.undefine(node.props.disabled);
    });
}

/**
 * Creates a new feature that generates a localization message of type ui
 * for use on a given component.
 *
 * @param key - The key of the message
 * @param value - The value of the message
 * @returns
 * @public
 */
function localize(key, value) {
    return (node) => {
        node.store.set(core.createMessage({
            key,
            type: 'ui',
            value: value || key,
            meta: {
                localize: true,
                i18nArgs: [node],
            },
        }));
    };
}

const isBrowser = typeof window !== 'undefined';
/**
 * Remove the data-file-hover attribute from the target.
 * @param e - Event
 */
function removeHover(e) {
    if (e.target instanceof HTMLElement &&
        e.target.hasAttribute('data-file-hover')) {
        e.target.removeAttribute('data-file-hover');
    }
}
/**
 * Prevent stray drag/drop events from navigating the window.
 * @param e - Event
 * @public
 */
function preventStrayDrop(type, e) {
    if (!(e.target instanceof HTMLInputElement)) {
        e.preventDefault();
    }
    else if (type === 'dragover') {
        e.target.setAttribute('data-file-hover', 'true');
    }
    if (type === 'drop') {
        removeHover(e);
    }
}
/**
 * Feature to add file handling support to an input.
 * @param node - The node being checked
 * @public
 */
function files(node) {
    // Localize our content:
    localize('noFiles', 'Select file')(node);
    localize('removeAll', 'Remove all')(node);
    localize('remove')(node);
    if (isBrowser) {
        if (!window._FormKit_File_Drop) {
            window.addEventListener('dragover', preventStrayDrop.bind(null, 'dragover'));
            window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'));
            window.addEventListener('dragleave', removeHover);
            window._FormKit_File_Drop = true;
        }
    }
    node.hook.input((value, next) => next(Array.isArray(value) ? value : []));
    node.on('created', () => {
        if (!Array.isArray(node.value))
            node.input([], false);
        if (!node.context)
            return;
        node.context.handlers.resetFiles = (e) => {
            e.preventDefault();
            node.input([]);
            if (node.props.id && isBrowser) {
                const el = document.getElementById(node.props.id);
                if (el)
                    el.value = '';
            }
        };
        node.context.handlers.files = (e) => {
            var _a, _b;
            const files = [];
            if (e.target instanceof HTMLInputElement && e.target.files) {
                for (let i = 0; i < e.target.files.length; i++) {
                    let file;
                    if ((file = e.target.files.item(i))) {
                        files.push({ name: file.name, file });
                    }
                }
                node.input(files);
            }
            if (node.context)
                node.context.files = files;
            // Call the original listener if there is one.
            if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {
                (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);
            }
        };
    });
}

/**
 * Handle the submit event.
 * @param e - The event
 * @public
 */
async function handleSubmit(node, submitEvent) {
    submitEvent.preventDefault();
    await node.settled;
    // Set the submitted state on all children
    node.walk((n) => {
        n.store.set(core.createMessage({
            key: 'submitted',
            value: true,
            visible: false,
        }));
    });
    if (typeof node.props.onSubmitRaw === 'function') {
        node.props.onSubmitRaw(submitEvent, node);
    }
    if (node.ledger.value('blocking')) {
        if (typeof node.props.onSubmitInvalid === 'function') {
            node.props.onSubmitInvalid(node);
        }
        // There is still a blocking message in the store.
        if (node.props.incompleteMessage !== false) {
            node.store.set(core.createMessage({
                blocking: false,
                key: `incomplete`,
                meta: {
                    localize: node.props.incompleteMessage === undefined,
                    i18nArgs: [{ node }],
                    showAsMessage: true,
                },
                type: 'ui',
                value: node.props.incompleteMessage || 'Form incomplete.',
            }));
        }
    }
    else {
        // No blocking messages
        if (typeof node.props.onSubmit === 'function') {
            // call onSubmit
            const retVal = node.props.onSubmit(node.hook.submit.dispatch(utils.clone(node.value)), node);
            if (retVal instanceof Promise) {
                const autoDisable = node.props.disabled === undefined &&
                    node.props.submitBehavior !== 'live';
                if (autoDisable)
                    node.props.disabled = true;
                node.store.set(core.createMessage({
                    key: 'loading',
                    value: true,
                    visible: false,
                }));
                await retVal;
                if (autoDisable)
                    node.props.disabled = false;
                node.store.remove('loading');
            }
        }
        else {
            if (submitEvent.target instanceof HTMLFormElement) {
                submitEvent.target.submit();
            }
        }
    }
}
/**
 * Converts the options prop to usable values.
 * @param node - A formkit node.
 * @public
 */
function form$1(node) {
    node.props.isForm = true;
    node.on('created', () => {
        var _a;
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.submit = handleSubmit.bind(null, node);
        }
        if (!utils.has(node.props, 'actions')) {
            node.props.actions = true;
        }
    });
    node.on('settled:blocking', () => node.store.remove('incomplete'));
}

/**
 * Applies ignore="true" by default.
 * @param node - The node
 * @public
 */
function ignore(node) {
    if (node.props.ignore === undefined) {
        node.props.ignore = true;
        node.parent = null;
    }
}

/**
 * Ensures the input has an `initialValue` prop.
 * @param node - The node being given an initial value
 * @public
 */
function initialValue(node) {
    node.on('created', () => {
        if (node.context) {
            node.context.initialValue = node.value || '';
        }
    });
}

/**
 * Sets the value of a radio button when checked.
 * @param node - FormKitNode
 * @param value - Value
 * @public
 */
function toggleChecked(node, event) {
    if (event.target instanceof HTMLInputElement) {
        node.input(optionValue(node.props.options, event.target.value));
    }
}
/**
 * Checks if the value being checked is the current value.
 * @param node - The node to check against.
 * @param value - The value to check
 * @returns
 */
function isChecked(node, value) {
    var _a, _b;
    // We need to force vue’s reactivity to respond when the value is run:
    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
    return shouldSelect(optionValue(node.props.options, value), node._value);
}
/**
 * Determines if a given radio input is being evaluated.
 * @param node - The radio input group.
 * @public
 */
function radios(node) {
    node.on('created', () => {
        var _a, _b;
        if (!Array.isArray(node.props.options)) {
            core.warn(350, node);
        }
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.toggleChecked = toggleChecked.bind(null, node);
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
            node.context.fns.isChecked = isChecked.bind(null, node);
        }
    });
    node.hook.prop(normalizeBoxes(node));
}

/**
 * Checks if a the given option should have the selected attribute.
 * @param node - The node being evaluated.
 * @param option - The option value to check
 * @returns
 * @public
 */
function isSelected(node, option) {
    // Here we trick reactivity (if at play) to watch this function.
    node.context && node.context.value;
    const optionValue = '__original' in option ? option.__original : option.value;
    function hasNoNullOption() {
        return !node.props.options.some((option) => ('__original' in option ? option.__original : option.value) === null);
    }
    return Array.isArray(node._value)
        ? node._value.some((optionA) => shouldSelect(optionA, optionValue))
        : (node._value === undefined ||
            (node._value === null && hasNoNullOption())) &&
            option.attrs &&
            option.attrs['data-is-placeholder']
            ? true
            : shouldSelect(optionValue, node._value);
}
/**
 * Defers the change event till after the next cycle.
 * @param node - The node being evaluated.
 * @param e - The change event.
 */
async function deferChange(node, e) {
    var _a;
    if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {
        await new Promise((r) => setTimeout(r, 0));
        await node.settled;
        node.props.attrs.onChange(e);
    }
}
/**
 * Select the correct values.
 * @param e - The input event emitted by the select.
 */
function selectInput(node, e) {
    const target = e.target;
    const value = target.hasAttribute('multiple')
        ? Array.from(target.selectedOptions).map((o) => optionValue(node.props.options, o.value))
        : optionValue(node.props.options, target.value);
    node.input(value);
}
/**
 * Appends a placeholder to the options list.
 * @param options - An options list
 * @param placeholder - A placeholder string to append
 * @returns
 */
function applyPlaceholder(options, placeholder) {
    if (!options.some((option) => option.attrs && option.attrs['data-is-placeholder'])) {
        return [
            {
                label: placeholder,
                value: '',
                attrs: {
                    hidden: true,
                    disabled: true,
                    'data-is-placeholder': 'true',
                },
            },
            ...options,
        ];
    }
    return options;
}
/**
 * Converts the options prop to usable values.
 * @param node - A formkit node.
 * @public
 */
function select$1(node) {
    // Set the initial value of a multi-input
    node.on('created', () => {
        var _a, _b, _c;
        const isMultiple = utils.undefine((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple);
        if (!isMultiple &&
            node.props.placeholder &&
            Array.isArray(node.props.options)) {
            node.hook.prop(({ prop, value }, next) => {
                if (prop === 'options') {
                    value = applyPlaceholder(value, node.props.placeholder);
                }
                return next({ prop, value });
            });
            node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);
        }
        if (isMultiple) {
            if (node.value === undefined) {
                node.input([], false);
            }
        }
        else if (node.context && !node.context.options) {
            // If this input is (probably) using the default slot, we need to add a
            // "value" attribute to get bound
            node.props.attrs = Object.assign({}, node.props.attrs, {
                value: node._value,
            });
            node.on('input', ({ payload }) => {
                node.props.attrs = Object.assign({}, node.props.attrs, {
                    value: payload,
                });
            });
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {
            node.context.handlers.selectInput = selectInput.bind(null, node);
            node.context.handlers.onChange = deferChange.bind(null, node);
        }
        if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {
            node.context.fns.isSelected = isSelected.bind(null, node);
            node.context.fns.showPlaceholder = (value, placeholder) => {
                if (!Array.isArray(node.props.options))
                    return false;
                const hasMatchingValue = node.props.options.some((option) => {
                    if (option.attrs && 'data-is-placeholder' in option.attrs)
                        return false;
                    const optionValue = '__original' in option ? option.__original : option.value;
                    return utils.eq(value, optionValue);
                });
                return placeholder && !hasMatchingValue ? true : undefined;
            };
        }
    });
    node.hook.input((value, next) => {
        var _a, _b, _c;
        if (!node.props.placeholder &&
            value === undefined &&
            Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) &&
            node.props.options.length &&
            !utils.undefine((_c = (_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.multiple)) {
            value =
                '__original' in node.props.options[0]
                    ? node.props.options[0].__original
                    : node.props.options[0].value;
        }
        return next(value);
    });
}

/**
 * @param sectionKey - the location the icon should be loaded
 * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS
 * @public
 */
function defaultIcon(sectionKey, defaultIcon) {
    return (node) => {
        if (node.props[`${sectionKey}Icon`] === undefined) {
            node.props[`${sectionKey}Icon`] = `default:${defaultIcon}`;
        }
    };
}

/**
 * Type guard for schema objects.
 * @param schema - returns true if the node is a schema node but not a string or conditional.
 * @public
 */
function isSchemaObject(schema) {
    return (typeof schema === 'object' &&
        ('$el' in schema || '$cmp' in schema || '$formkit' in schema));
}
/**
 * Checks if the current schema node is a slot condition like:
 * ```js
 * {
 *  if: '$slot.name',
 *  then: '$slot.name',
 *  else: []
 * }
 * ```
 * @param node - a schema node
 * @returns
 * @public
 */
function isSlotCondition(node) {
    if (core.isConditional(node) &&
        node.if &&
        node.if.startsWith('$slots.') &&
        typeof node.then === 'string' &&
        node.then.startsWith('$slots.') &&
        'else' in node) {
        return true;
    }
    return false;
}
/**
 * Extends a single schema node with an extension. The extension can be any partial node including strings.
 * @param schema - Extend a base schema node.
 * @param extension - The values to extend on the base schema node.
 * @returns
 * @public
 */
function extendSchema(schema, extension = {}) {
    if (typeof schema === 'string') {
        return isSchemaObject(extension) || typeof extension === 'string'
            ? extension
            : schema;
    }
    else if (Array.isArray(schema)) {
        return isSchemaObject(extension) ? extension : schema;
    }
    return utils.extend(schema, extension);
}
/**
 * ================================================================
 * NOTE: This function is deprecated. Use `createSection` instead!
 * ================================================================
 *
 * @param key - A new section key name.
 * @param schema - The default schema in this composable slot.
 * @returns
 * @public
 */
function composable(key, schema) {
    core.warn(800, 'composable function');
    return (extendWith = {}, children = undefined) => {
        const root = typeof schema === 'function'
            ? schema(children)
            : typeof schema === 'object'
                ? utils.clone(schema)
                : schema;
        const isObj = isSchemaObject(root);
        if (isObj && !('children' in root) && children) {
            if (Array.isArray(children)) {
                if (children.length) {
                    root.children = children;
                }
            }
            else {
                root.children = [children];
            }
        }
        const extended = extendSchema(root, extendWith);
        return {
            if: `$slots.${key}`,
            then: `$slots.${key}`,
            else: Array.isArray(extended) ? extended : [extended],
        };
    };
}
/**
 * Creates an input schema with all of the wrapping base schema.
 * @param inputSchema - Content to store in the input section key location.
 * @public
 */
function useSchema(inputSection) {
    return outer(wrapper(label('$label'), inner(prefix(), inputSection(), suffix())), help('$help'), messages(message('$message.value')));
}
/**
 * Creates a new reusable section.
 * @param section - A single section of schema
 * @param el - The element or a function that returns a schema node.
 * @param root - When true returns an extendable root schema node.
 * @returns
 * @public
 */
function createSection(section, el, root = false) {
    return (...children) => {
        const extendable = (extensions) => {
            const node = !el || typeof el === 'string' ? { $el: el } : el();
            if (core.isDOM(node) || core.isComponent(node)) {
                if (!node.meta) {
                    node.meta = { section };
                }
                if (children.length && !node.children) {
                    node.children = [
                        ...children.map((child) => typeof child === 'string' ? child : child(extensions)),
                    ];
                }
                if (core.isDOM(node)) {
                    node.attrs = {
                        class: `$classes.${section}`,
                        ...(node.attrs || {}),
                    };
                }
            }
            return {
                if: `$slots.${section}`,
                then: `$slots.${section}`,
                else: section in extensions
                    ? extendSchema(node, extensions[section])
                    : node,
            };
        };
        return root ? createRoot(extendable) : extendable;
    };
}
/**
 * Returns an extendable schema root node.
 * @param rootSection - Creates the root node.
 * @returns
 */
function createRoot(rootSection) {
    return (extensions) => {
        return [rootSection(extensions)];
    };
}
/**
 * Applies attributes to a given schema section by applying a higher order
 * function that merges a given set of attributes into the node.
 * @param attrs - Apply attributes to a FormKitSchemaExtendableSection
 * @param section - A section to apply attributes to
 * @returns
 * @public
 */
function $attrs(attrs, section) {
    return (extensions) => {
        const node = section(extensions);
        const attributes = typeof attrs === 'function' ? attrs() : attrs;
        if (!utils.isObject(attributes))
            return node;
        if (isSlotCondition(node) && core.isDOM(node.else)) {
            node.else.attrs = { ...node.else.attrs, ...attributes };
        }
        else if (core.isDOM(node)) {
            node.attrs = { ...node.attrs, ...attributes };
        }
        return node;
    };
}
/**
 *
 * @param condition - A schema condition to apply to a section.
 * @param then - The section that applies if the condition is true.
 * @param otherwise - (else) The section that applies if the condition is false.
 * @returns
 * @public
 */
function $if(condition, then, otherwise) {
    return (extensions) => {
        const node = then(extensions);
        if (otherwise ||
            (isSchemaObject(node) && 'if' in node) ||
            isSlotCondition(node)) {
            const conditionalNode = {
                if: condition,
                then: node,
            };
            if (otherwise) {
                conditionalNode.else = otherwise(extensions);
            }
            return conditionalNode;
        }
        else if (isSlotCondition(node)) {
            Object.assign(node.else, { if: condition });
        }
        else if (isSchemaObject(node)) {
            Object.assign(node, { if: condition });
        }
        return node;
    };
}
/**
 * Applies a condition to a given schema section.
 * @param varName - The name of the variable that holds the current instance.
 * @param inName - The variable we are iterating over.
 * @param section - A section to repeat
 * @returns
 * @public
 */
function $for(varName, inName, section) {
    return (extensions) => {
        const node = section(extensions);
        if (isSlotCondition(node)) {
            Object.assign(node.else, { for: [varName, inName] });
        }
        else if (isSchemaObject(node)) {
            Object.assign(node, { for: [varName, inName] });
        }
        return node;
    };
}
/**
 * Extends a schema node with a given set of extensions.
 * @param section - A section to apply an extension to.
 * @param extendWith - A partial schema snippet to apply to the section.
 * @returns
 * @public
 */
function $extend(section, extendWith) {
    return (extensions) => {
        const node = section({});
        if (isSlotCondition(node)) {
            if (Array.isArray(node.else))
                return node;
            node.else = extendSchema(extendSchema(node.else, extendWith), extensions);
            return node;
        }
        return extendSchema(extendSchema(node, extendWith), extensions);
    };
}
/**
 * Creates a root schema section.
 * @param section - A section to make a root from.
 * @returns
 * @public
 */
function $root(section) {
    return createRoot(section);
}

/**
 * Input definition for a button.
 * @public
 */
const button = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: outer(messages(message('$message.value')), wrapper(buttonInput(icon('prefix'), prefix(), buttonLabel('$label || $ui.submit.value'), suffix(), icon('suffix'))), help('$help')),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'button',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [localize('submit'), ignore],
};

/**
 * Input definition for a checkbox(ess).
 * @public
 */
const checkbox = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: outer($if('$options == undefined', 
    /**
     * Single checkbox structure.
     */
    boxWrapper(inner(prefix(), box(), decorator(icon('decorator')), suffix()), $extend(boxLabel('$label'), {
        if: '$label',
    })), 
    /**
     * Multi checkbox structure.
     */
    fieldset(legend('$label'), help('$help'), boxOptions(boxOption(boxWrapper(inner(prefix(), $extend(box(), {
        bind: '$option.attrs',
        attrs: {
            id: '$option.attrs.id',
            value: '$option.value',
            checked: '$fns.isChecked($option.value)',
        },
    }), decorator(icon('decorator')), suffix()), $extend(boxLabel('$option.label'), {
        if: '$option.label',
    })), boxHelp('$option.help'))))), 
    // Help text only goes under the input when it is a single.
    $if('$options == undefined && $help', help('$help')), messages(message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'box',
    /**
     * An array of extra props to accept for this input.
     */
    props: ['options', 'onValue', 'offValue', 'optionsLoader'],
    /**
     * Additional features that should be added to your input
     */
    features: [
        options,
        checkboxes,
        defaultIcon('decorator', 'checkboxDecorator'),
    ],
};

/**
 * Input definition for a file input.
 * @public
 */
const file = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), fileInput(), fileList(fileItem(icon('fileItem'), fileName('$file.name'), $if('$value.length === 1', fileRemove(icon('fileRemove'), '$ui.remove.value')))), $if('$value.length > 1', fileRemove('$ui.removeAll.value')), noFiles(icon('noFiles'), '$ui.noFiles.value'), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'text',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [
        files,
        defaultIcon('fileItem', 'fileItem'),
        defaultIcon('fileRemove', 'fileRemove'),
        defaultIcon('noFiles', 'noFiles'),
    ],
};

/**
 * Input definition for a form.
 * @public
 */
const form = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: formInput('$slots.default', messages(message('$message.value')), actions(submitInput())),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'group',
    /**
     * An array of extra props to accept for this input.
     */
    props: [
        'actions',
        'submit',
        'submitLabel',
        'submitAttrs',
        'submitBehavior',
        'incompleteMessage',
    ],
    /**
     * Additional features that should be added to your input
     */
    features: [form$1, disables],
};

/**
 * Input definition for a group.
 * @public
 */
const group = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: fragment('$slots.default'),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'group',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [disables],
};

/**
 * Input definition for a hidden input.
 * @public
 */
const hidden = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: $root(textInput()),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [],
};

/**
 * Input definition for a list.
 * @public
 */
const list = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: fragment('$slots.default'),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'list',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [disables],
};

/**
 * Input definition for a radio.
 * @public
 */
const radio = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: outer($if('$options == undefined', 
    /**
     * Single radio structure.
     */
    boxWrapper(inner(prefix(), box(), decorator(icon('decorator')), suffix()), $if('$label', boxLabel('$label'))), 
    /**
     * Multi radio structure.
     */
    fieldset(legend('$label'), help('$help'), boxOptions(boxOption(boxWrapper(inner(prefix(), $extend(box(), {
        bind: '$option.attrs',
        attrs: {
            id: '$option.attrs.id',
            value: '$option.value',
            checked: '$fns.isChecked($option.value)',
        },
    }), decorator(icon('decorator')), suffix()), $if('$option.label', boxLabel('$option.label'))), boxHelp('$option.help'))))), 
    // Help text only goes under the input when it is a single.
    $if('$options === undefined && $help', help('$help')), messages(message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'box',
    /**
     * An array of extra props to accept for this input.
     */
    props: ['options', 'onValue', 'offValue', 'optionsLoader'],
    /**
     * Additional features that should be added to your input
     */
    features: [options, radios, defaultIcon('decorator', 'radioDecorator')],
};

/**
 * Input definition for a select.
 * @public
 */
const select = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: outer(wrapper(label('$label'), inner(icon('prefix'), prefix(), selectInput$1($if('$slots.default', () => '$slots.default', $if('$slots.option', optionSlot, option('$option.label')))), $if('$attrs.multiple !== undefined', () => '', icon('select')), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * An array of extra props to accept for this input.
     */
    props: ['options', 'placeholder', 'optionsLoader'],
    /**
     * Additional features that should be added to your input
     */
    features: [options, select$1, defaultIcon('select', 'select')],
};

/**
 * Input definition for a textarea.
 * @public
 */
const textarea = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), textareaInput(), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [initialValue],
};

/**
 * Input definition for a text.
 * @public
 */
const text = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), textInput(), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'text',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [],
};

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    button: button,
    submit: button,
    checkbox: checkbox,
    file: file,
    form: form,
    group: group,
    hidden: hidden,
    list: list,
    radio: radio,
    select: select,
    textarea: textarea,
    text: text,
    color: text,
    date: text,
    datetimeLocal: text,
    email: text,
    month: text,
    number: text,
    password: text,
    search: text,
    tel: text,
    time: text,
    url: text,
    week: text,
    range: text
});

exports.$attrs = $attrs;
exports.$extend = $extend;
exports.$for = $for;
exports.$if = $if;
exports.$root = $root;
exports.actions = actions;
exports.box = box;
exports.boxHelp = boxHelp;
exports.boxLabel = boxLabel;
exports.boxOption = boxOption;
exports.boxOptions = boxOptions;
exports.boxWrapper = boxWrapper;
exports.button = button;
exports.buttonInput = buttonInput;
exports.buttonLabel = buttonLabel;
exports.checkbox = checkbox;
exports.checkboxes = checkboxes;
exports.color = text;
exports.composable = composable;
exports.createLibraryPlugin = createLibraryPlugin;
exports.createSection = createSection;
exports.date = text;
exports.datetimeLocal = text;
exports.decorator = decorator;
exports.defaultIcon = defaultIcon;
exports.disablesChildren = disables;
exports.email = text;
exports.extendSchema = extendSchema;
exports.fieldset = fieldset;
exports.file = file;
exports.fileInput = fileInput;
exports.fileItem = fileItem;
exports.fileList = fileList;
exports.fileName = fileName;
exports.fileRemove = fileRemove;
exports.files = files;
exports.form = form;
exports.formInput = formInput;
exports.forms = form$1;
exports.fragment = fragment;
exports.group = group;
exports.help = help;
exports.hidden = hidden;
exports.icon = icon;
exports.ignores = ignore;
exports.initialValue = initialValue;
exports.inner = inner;
exports.inputs = index;
exports.isSchemaObject = isSchemaObject;
exports.isSlotCondition = isSlotCondition;
exports.label = label;
exports.legend = legend;
exports.list = list;
exports.localize = localize;
exports.message = message;
exports.messages = messages;
exports.month = text;
exports.noFiles = noFiles;
exports.normalizeBoxes = normalizeBoxes;
exports.normalizeOptions = normalizeOptions;
exports.number = text;
exports.option = option;
exports.optionSlot = optionSlot;
exports.options = options;
exports.outer = outer;
exports.password = text;
exports.prefix = prefix;
exports.radio = radio;
exports.radios = radios;
exports.range = text;
exports.search = text;
exports.select = select;
exports.selectInput = selectInput$1;
exports.selects = select$1;
exports.submit = button;
exports.submitInput = submitInput;
exports.suffix = suffix;
exports.tel = text;
exports.text = text;
exports.textInput = textInput;
exports.textarea = textarea;
exports.textareaInput = textareaInput;
exports.time = text;
exports.url = text;
exports.useSchema = useSchema;
exports.week = text;
exports.wrapper = wrapper;
